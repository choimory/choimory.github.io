---
title: "식별자 채번 전략 AUTO_INCREMENT, UUID, ULID, TSID"
date: 2025-09-11T00:00:00
toc: true
toc_sticky: true
categories:
    - DB
tags:
    - UUID
    - PK
---

# 식별자 채번 전략

- `AUTO_INCREMENT`, `UUID`, `ULID`, `TSID`는 각각 고유 식별자를 생성하는 방식이지만, 성능과 유일성, 사용 환경에 따라 적합한 방식이 달라진다.
- **AUTO_INCREMENT**는 단일 서버 환경에서 빠르고 효율적이지만, 분산 환경에는 적합하지 않다.
- **UUID**는 분산 환경에서 유일성을 보장할 수 있지만, 크기와 성능 측면에서 단점이 있다.
- **ULID**는 시간 기반으로 순차적으로 증가하고 정렬이 가능하여, 성능과 유일성 모두 고려한 좋은 선택이다.
- **TSID**는 ULID와 유사하지만 더 간결하고 효율적이어서 간단한 분산 시스템에서 유용하다.

# AUTO_INCREMENT

- `AUTO_INCREMENT`는 데이터베이스에서 자동으로 증가하는 정수 값으로, 주로 MySQL, PostgreSQL 등의 관계형 데이터베이스에서 사용된다.
- **장점**:
    - **간단하고 직관적**: 데이터베이스 내에서 자동으로 증가하므로 별도의 복잡한 로직이 필요 없다.
    - **저장 공간 효율적**: 숫자형 데이터는 저장 공간을 적게 차지한다.
    - **빠른 성능**: 숫자형 인덱스를 사용하므로 조회 성능이 우수하다.
- **단점**:
    - **분산 환경에서 비효율적**: 분산 환경에서는 `AUTO_INCREMENT` 값을 각 서버에서 독립적으로 관리하기 어려워, 동기화 문제가 발생할 수 있다.
    - **예측 가능성**: 외부에서 `AUTO_INCREMENT` 값을 예측할 수 있어 보안에 취약할 수 있다.

# UUID

- UUID는 128비트 길이의 고유 식별자를 생성하는 방식으로, `UUID v1`, `UUID v4` 등 다양한 버전이 존재한다.
- **장점**:
    - **글로벌 유일성**: 분산 환경에서도 유일성을 보장한다.
    - **서버 간 독립적 생성 가능**: 서버 간 동기화 없이 각 서버에서 독립적으로 UUID를 생성할 수 있다.
- **단점**:
    - **길이**: 128비트(16바이트)의 길이로, 저장 공간을 많이 차지한다.
    - **성능 문제**: 길이가 길고 랜덤한 값을 포함하여 인덱스 성능이 저하될 수 있다.
    - **정렬이 불편**: 생성된 UUID는 시간 순으로 정렬되지 않아, 정렬 성능이 떨어질 수 있다.

# ULID

- ULID는 UUID와 유사하지만, 타임스탬프 기반으로 순차적으로 증가하는 고유 식별자를 생성하는 방식이다.
- 128비트로 UUID와 동일한 크기를 가지나, 고유성과 정렬 가능성을 모두 고려한 방식이다.
- **장점**:
    - **정렬 가능**: ULID는 시간 순서대로 정렬 가능하여, 시간에 따라 데이터가 정렬되는 특성이 필요할 경우 유리하다.
    - **고유성**: 각 ULID는 시간, 랜덤 값, 서버 식별자 등을 포함해 유일성을 보장한다.
    - **공간 효율적**: UUID보다는 더 짧은 문자열로 표현할 수 있어 저장 공간이 더 효율적이다.
- **단점**:
    - **타임스탬프 기반**: 타임스탬프를 기반으로 하여 순차적으로 증가하지만, 일부 분산 환경에서는 시간 동기화 문제가 발생할 수 있다.
    - **생성 로직 복잡성**: UUID보다는 조금 더 복잡한 생성 로직이 필요하다.

# TSID

- TSID는 시간 기반 고유 식별자 생성 방식으로, `ULID`와 유사하지만 더욱 간단하고 효율적인 설계를 지향한다.
- 주로 64비트 또는 128비트로 구성되며, 타임스탬프와 서버 ID 등을 결합해 고유성을 보장한다.
- **장점**:
    - **시간 기반**: 타임스탬프 기반으로 생성되므로, 시간 순으로 정렬이 가능하고 순차적으로 증가한다.
    - **간단하고 효율적**: UUID보다 간결한 구조로, 더 빠르고 효율적으로 생성할 수 있다.
    - **고유성 보장**: 서버 ID, 시간, 시퀀스 등을 포함하여 고유성을 보장한다.
- **단점**:
    - **정밀도 문제**: 시간 기반으로 생성되므로, 매우 빠른 요청에서 중복이 발생할 가능성이 있다(밀리초 단위로 충분한 고유성을 제공해야 한다).
    - **분산 환경에서 서버 ID 관리 필요**: 분산 환경에서는 각 서버에 고유한 ID를 부여해야 한다.

# **비교 요약**

| 특성 | AUTO_INCREMENT | UUID | ULID | TSID |
| --- | --- | --- | --- | --- |
| **길이** | 짧음 (정수) | 길음 (128비트, 16바이트) | 중간 (128비트, 16바이트) | 중간 (64비트 또는 128비트) |
| **정렬 가능** | 아니오 | 아니오 | 예 (시간 순서대로 정렬 가능) | 예 (시간 순서대로 정렬 가능) |
| **성능** | 우수 (숫자형) | 낮음 (길고 랜덤함) | 우수 (시간 순서대로 증가) | 우수 (시간 순서대로 증가) |
| **유일성** | 서버 내에서만 유일함 | 전 세계적으로 유일함 | 전 세계적으로 유일함 | 전 세계적으로 유일함 |
| **분산 환경** | 비효율적 | 효율적 | 효율적 | 효율적 |
| **저장 공간** | 효율적 | 비효율적 (128비트) | 효율적 (비교적 짧은 크기) | 효율적 (비교적 짧은 크기) |