---
title: "MSA API 아키텍처들에 대해"
date: 2025-08-17T00:00:00
toc: true
toc_sticky: true
categories:
    - Back-end
tags:
    - MSA
    - API
    - Architecture
---

# intro

- 모놀리스로 시작해 현재의 MSA에 이르기까지 다양한 아키텍처로 변화해가는 흐름을 이해함

# 모놀리스

- 하나의 API, 하나의 DB
- 집약적이고 관리가 쉬움
- CRUD 기반으로 단순명료함
- 대용량 DB와 대규모 트래픽에 모두 취약함
- 하나의 장애가 모든 서비스에 전파됨

# 여러개의 REST API, 하나의 DB

- 대규모 트래픽에 대응하고 에러전파의 범위를 줄임
- 대용량 DB에는 여전히 취약함
- DB 장애에는 여전히 전파력이 높음
- 특정 테이블에 집중적인 부하
- 특정 테이블의 변경시 다른 서비스들에 모두 동기화 문제 발생

# 여러개의 REST API, 별도의 DB

- 다른 서비스의 데이터가 필요할때마다 API간의 통신이 발생
- HTTP로 API간의 통신은 너무 무겁다

# gRPC

- API간의 통신을 더욱 가볍게
- 결국 또 서비스간의 통신이 물고 물리면서 결합이 강해짐

# EDA

- API간의 통신 결합을 느슨하게
- 직접적인 통신이 필요한것들은 어쩔수 없지만 그렇지 않은것들은 pub만 하고, 다른쪽은 sub만 하면서 결합을 낮추자
- 하지만 API간의 분산, DB간의 분산이 이루어지면서, 몇몇 API와 DB작업을 묶어 하나의 트랜잭션으로 묶어야 할때 특정부분에서의 장애시 rollback하기가 힘듬

# SAGA

- EDA에 SAGA를 결합시켜서, 특정 로직에 대한 필요 이벤트들을 발행하는 SAGA 중개자를 두고, 어느 한 이벤트 발행 실패시 보상트랜잭션을 발행하여 롤백하게함
- 서비스, 이벤트별로 DB를 용도에 맞게 처리하지 못하면서 DB를 효율적으로 쓰지 못함

# CQRS

- 명령(쓰기수정삭제, command)와 쿼리(조회, query)를 분리하여 용도에 맞게 DB를 효율적으로 사용하게 함
- 명령과 쿼리 DB를 master, slave로 튜닝한 DB로 나눌수도 있고 RDBMS와 NoSQL로 나눌수도 있음
- 조회는 조회에 유리한 DB를 쓰고, 쓰기수정삭제는 해당부분에 유리한 DB를 사용하며, 중간에 각 DB간의 동기화 처리를 하나 둠

# ref

- https://www.youtube.com/watch?v=e8iAR3VWffM