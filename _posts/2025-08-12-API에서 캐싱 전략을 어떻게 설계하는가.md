---
title: "API에서 캐싱 전략을 어떻게 설계하는가"
date: 2025-08-12T00:00:00
toc: true
toc_sticky: true
categories:
    - Back-end
tags:
    - MSA
    - API
    - Cache
---

# API에서 캐싱의 역할과 필요성

- 캐싱은 API의 응답 데이터를 임시로 저장하여 서버 부하를 줄이고 클라이언트 요청의 응답 시간을 단축하는 전략이다.
- 적절한 캐싱 전략은 성능 최적화, 대역폭 절감, 그리고 사용자의 경험 향상에 중요한 역할을 한다.
- API 캐싱 전략 설계는 **캐시 저장 위치**, **캐시 지속 시간**, **데이터 변경 시 동작** 등을 고려하여 설계해야 한다.

---

# 캐싱 전략 설계의 주요 요소

## **캐시 저장 위치**

### **클라이언트 측 캐싱**:

- 데이터를 브라우저 또는 클라이언트 애플리케이션에 저장.
- HTTP 캐시 헤더(`Cache-Control`, `Expires` 등)를 통해 구현.

### **프록시 서버 캐싱**:

- 프록시 서버(Nginx, CDN 등)가 데이터를 캐싱.
- 공용 API 응답의 성능 최적화에 적합.

### **서버 측 캐싱**:

- 백엔드에서 캐시를 유지(예: Redis, Memcached).
- 데이터베이스 쿼리 결과나 비싼 연산의 결과를 저장.

## **캐시 지속 시간**

### **짧은 TTL (Time to Live)**:

- 데이터가 자주 변경되면 캐시의 유효 기간을 짧게 설정.

### **긴 TTL**:

- 데이터가 자주 변경되지 않는 경우 유효 기간을 길게 설정.

## **데이터 변경 시 동작**

### **강제 무효화**:

- 데이터 변경 시 캐시를 삭제 또는 갱신.

### **정확한 타임스탬프 사용**:

- 데이터 변경 시간을 기준으로 캐시를 재검증.

## **캐싱 스코프**

### **전역 캐싱**:

- 모든 사용자가 동일한 데이터를 공유.

### **사용자별 캐싱**:

- 사용자마다 개별 데이터를 캐싱.

---

# 캐싱 전략 설계 방법

## **HTTP 캐싱 헤더 설정**

- **Cache-Control**: 응답의 캐싱 정책을 정의.
    - `no-cache`: 데이터가 캐시되지만, 서버에서 항상 유효성 확인.
    - `no-store`: 데이터를 캐싱하지 않음.
    - `max-age`: 데이터 캐싱 유효 기간(초 단위).
    - 예:
        
        ```arduino
        Cache-Control: public, max-age=3600
        ```
        
- **ETag**: 데이터의 변경 여부를 확인하는 고유 식별자.
    - 클라이언트가 요청 시 ETag를 포함하면, 서버는 변경 여부를 확인해 `304 Not Modified` 응답을 반환.
    - 예:
        
        ```vbnet
        ETag: "abc123"
        ```
        
- **Expires**: 캐싱 만료 시간을 명시.
    - 예:
        
        ```yaml
        Expires: Wed, 21 Oct 2023 07:28:00 GMT
        ```
        

## **프록시 서버 및 CDN 캐싱**

- **프록시 서버 캐싱**: Nginx나 Apache를 활용해 공용 캐싱 계층을 구성.
- **CDN 캐싱**: 콘텐츠 전달 네트워크(CDN)를 활용해 정적 자원과 공용 API 응답 캐싱.

**Nginx 캐싱 설정 예**:

```
location /api/ {
    proxy_cache my_cache;
    proxy_cache_valid 200 1h;
    add_header X-Cache-Status $upstream_cache_status;
}
```

## **서버 측 캐싱**

- 데이터베이스 쿼리 결과, 계산 비용이 큰 데이터 등을 캐싱.
- Redis, Memcached와 같은 고성능 인메모리 캐시 사용.

**Redis 캐싱 예**:

```python
import redis

cache = redis.Redis(host='localhost', port=6379, db=0)

def get_data(key):
    data = cache.get(key)
    if data:
        return data
    else:
        data = fetch_from_database(key)
        cache.set(key, data, ex=3600)  # 1시간 동안 캐싱
        return data
```

## **계층적 캐싱**

- 캐시 계층을 여러 단계로 나누어, 요청을 효율적으로 처리.
- **클라이언트 → CDN → 프록시 서버 → 원본 서버**
- 각 단계에서 캐싱 여부를 확인하고 요청을 처리.

---

# 캐싱 전략 선택 시 고려사항

## **데이터 특성**

- 자주 변경되지 않는 데이터: 긴 TTL 사용.
- 실시간으로 변경되는 데이터: 짧은 TTL 또는 ETag 기반 검증.

## **사용 사례**

- 정적 데이터(API 스키마, 공용 리소스): 클라이언트 또는 CDN 캐싱.
- 사용자 맞춤 데이터(대시보드, 프로필): 서버 측 캐싱 또는 사용자별 캐싱.

## **캐시 적중률(Cache Hit Rate) 최적화**

- 캐시 정책을 최적화해 적중률을 높이면, 성능이 향상되고 서버 부하가 감소.

## **캐시 일관성 유지**

- 데이터 변경 시 캐시를 적시에 무효화하여 최신 데이터를 제공.

---

# 장점

## 성능 향상:

- 응답 시간 단축 및 서버 부하 감소.

## 대역폭 절감:

- 동일 요청에 대한 반복 전송 최소화.

## 확장성:

- 대규모 트래픽 처리 능력 향상.

# 단점

## 일관성 문제:

- 캐시된 데이터가 최신 상태와 다를 수 있음.

## 복잡성 증가:

- 캐시 갱신 및 무효화 로직 관리 필요.

## 메모리 비용:

- 캐싱 시스템 구축 및 유지 비용 발생.

---

# **요약**

- API 캐싱은 클라이언트, 프록시 서버, 서버 등 여러 위치에서 구현될 수 있다.
- 주요 전략으로 HTTP 캐싱 헤더, CDN, 서버 측 캐싱, 계층적 캐싱 등이 있으며, 데이터 특성에 따라 TTL, ETag, Cache-Control을 적절히 설정해야 한다.
- 적절한 캐싱 전략은 성능을 향상시키면서도 데이터 일관성을 유지하는 데 필수적이다.