---
title: "JPA Proxy"
date: 2025-08-30T00:00:00
toc: true
toc_sticky: true
categories:
    - Back-end
tags:
    - JPA
---

# JPA Proxy

`JPA Proxy`는 JPA(EntityManager)가 엔티티를 조회할 때 실제 엔티티 객체 대신 프록시 객체를 반환하는 기능

 주로 **지연 로딩(Lazy Loading)** 을 지원하기 위해 사용

### 1. 프록시란?

- **실제 객체를 감싸고 있는 대리 객체**
- 실제 객체에 접근할 때 필요한 작업을 사전에 수행할 수 있음

### 2. 언제 생성되나?

- `@ManyToOne(fetch = FetchType.LAZY)` 같은 연관관계에서 Lazy 옵션이 설정된 경우
- `em.getReference()` 로 객체를 조회할 때

```java
Member member = em.getReference(Member.class, 1L);
```

이렇게 하면 `Member` 객체가 바로 조회되지 않고, 프록시 객체가 리턴됨.

### 3. 프록시의 특징

- 실제 클래스가 아니라 **하위 클래스** 형태로 생성됨 (ByteBuddy, CGLIB 사용)
- 실제 데이터는 **프록시 객체를 사용할 때** (예: getter 호출) 초기화됨
- `instanceof` 연산자로 원래 클래스인지 확인하면 true 반환됨
- 단, `==` 연산으로 비교하면 실제 엔티티와 다름

### 4. 프록시 주의사항

- **초기화되지 않은 프록시에 접근하면 LazyInitializationException 발생** (영속성 컨텍스트가 닫힌 경우)
- **equals, hashCode 구현 시 주의 필요**
    - 프록시는 실제 객체와 다를 수 있으므로 `equals` 에서 클래스 비교 대신 식별자(id) 비교 위주로 구현하는 게 좋음

### 5. 초기화 여부 확인 방법

```java
emf.getPersistenceUnitUtil().isLoaded(proxyObject);
```

---

# 영속성 컨텍스트와의 관계

JPA 프록시는 **영속성 컨텍스트와 아주 밀접한 관계**

이걸 이해하려면 프록시 객체가 실제 데이터를 어떻게 로딩하는지를 봐야 함

### 1. 프록시는 "게으른 로딩용 껍데기"

```java
Member member = em.getReference(Member.class, 1L);
```

이 시점엔 실제 DB 조회가 일어나지 않음. 

`member`는 프록시 객체일 뿐, 진짜 데이터는 없음.

### 2. **프록시가 동작하려면 영속성 컨텍스트가 살아있어야 함**

- 프록시는 내부적으로 `EntityManager` (정확히는 영속성 컨텍스트)에 의존해서 DB에서 실제 데이터를 가져옴
- 만약 프록시 객체를 사용하는 시점에 영속성 컨텍스트가 닫혀 있다면?

```java
em.close();
member.getName(); // LazyInitializationException 발생!
```

- 이건 프록시가 실제 데이터를 로딩하려고 하는데, 영속성 컨텍스트가 없어서 데이터 로딩이 불가능한 상태

### 3. 영속성 컨텍스트가 관리하는 프록시

- 프록시 객체도 **영속성 컨텍스트가 관리하는 엔티티의 일종**
- `em.contains(proxy)` → true
- 프록시가 초기화되면, 영속성 컨텍스트는 이를 실제 엔티티처럼 취급함

### 4. 정리: 프록시와 영속성 컨텍스트 관계 핵심

| 항목 | 설명 |
| --- | --- |
| 생성 시점 | 영속성 컨텍스트가 `getReference()` 또는 `LAZY` 로 생성함 |
| 의존성 | 실제 데이터 로딩 시 영속성 컨텍스트가 필요함 |
| 초기화 시점 | 프록시를 사용할 때 (메서드 호출 등) |
| 문제 상황 | 영속성 컨텍스트가 닫힌 후 접근 시 예외 발생 |

---

# 실제 객체와 프록시 객체?

- **프록시 객체는 지연 로딩용 껍데기**
    - 연관관계가 `LAZY`일 때, 프록시 객체만 만들어두고 DB 접근은 안 함
    - 프록시에 실제 접근(getter 등)할 때 영속성 컨텍스트를 통해 DB에서 데이터 조회함
- **프록시 객체의 변경은 실제 DB 반영 가능**
    - 프록시든 실제 엔티티든 결국 영속성 컨텍스트가 추적 중인 객체이기 때문에 변경 사항은 감지되고, 트랜잭션 커밋 시 DB에 반영됨
- **프록시 객체는 실제 엔티티 역할을 대신함**
    - 영속성 컨텍스트는 실제 엔티티가 아니라 **프록시 객체 그 자체**를 관리함.
    - 즉, `getReference()`로 만든 프록시 객체가 영속성 컨텍스트에 등록돼
    - 따로 실제 엔티티 객체를 별도로 하나 더 관리하지 않음
- 프록시 객체는 실제 엔티티 객체로 변하는 게 아님
    - 내부적으로 데이터만 채워짐
    - 프록시 객체는 끝까지 프록시 객체
    - 프록시는 껍데기지만, 내부에 데이터가 채워지면 ‘진짜처럼’ 행동함
    - 하지만 그 껍데기는 여전히 프록시
    - **껍데기를 벗고 진짜가 되는 건 아님**
    - 프록시 객체가 논리적으로만 진짜 엔티티 객체가 되는것이지, 사용되는 객체는 여전히 프록시 객체임

---

# 정리

- 지연로딩 설정된 연관관계 필드의 엔티티는 프록시로 생성된다
- 해당 프록시 객체는 값이 비어져있다가 접근할때 DB 조회를 거쳐 값이 채워진다 (지연로딩)
- 해당 프록시 객체는 그때부터는 이제 영속성 컨텍스트에 의해 논리적으로는 실제 엔티티 객체 취급받아 다뤄지게 되지만, 객체자체는 여전히 프록시 객체이다 (Entity$Proxy….)