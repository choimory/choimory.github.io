---
title: "B Tree"
date: 2026-01-13T00:00:00
toc: true
toc_sticky: true
categories:
    - DB
tags:
    - Index
    - Tree
---

# B-Tree, B+Tree

- **B-Tree**와 **B+Tree**는 데이터베이스 및 파일 시스템에서 인덱스 구조로 사용되는 트리 기반 자료구조다.
- 둘 다 검색, 삽입, 삭제 등의 작업에서 **균형 잡힌 트리**를 유지하며 효율적인 성능을 제공하지만, 두 자료구조는 약간의 차이점이 있다.
- 이 차이점은 주로 **데이터 저장 위치**와 **범위 검색**에서 나타난다.

---

# B-Tree

- **B-Tree**는 **균형 트리**로, 모든 리프 노드가 같은 깊이에 있으며, 노드가 **다수의 자식 노드**를 가질 수 있는 트리 구조이다.
- B-Tree는 데이터베이스에서 검색과 같은 다양한 연산을 효율적으로 수행하기 위해 설계되었다.

## B-Tree의 특징:

- **데이터 저장 위치**:
    - B-Tree는 모든 노드(내부 노드와 리프 노드)에 데이터를 저장할 수 있다.
    - 즉, 내부 노드에도 실제 데이터가 저장되고, 리프 노드에도 저장된다.
- **균형 트리**:
    - B-Tree는 항상 균형을 유지하므로, 삽입, 삭제, 검색 등의 연산이 O(log N)의 시간 복잡도로 수행된다.
- **포인터**:
    - 내부 노드에는 데이터뿐만 아니라 **포인터**가 포함되어 있어 자식 노드를 가리킨다.
    - 트리의 각 노드에는 여러 개의 포인터가 존재한다.
- **범위 검색**:
    - 리프 노드가 **연결되어 있지 않으므로** 범위 검색이 상대적으로 비효율적이다.
    - 순차적으로 검색할 때 자식 노드를 따라가며 검색을 계속해야 한다.
- **사용 사례**:
    - 범위 검색이 빈번하지 않은 경우 B-Tree는 적합하며, 삽입과 삭제가 빈번한 경우에도 적절하다.

## B-Tree의 구조:

- **내부 노드**: 데이터와 포인터를 포함. 각 포인터는 자식 노드를 가리킨다.
- **리프 노드**: 데이터가 저장된 노드로, 더 이상 자식 노드가 없는 트리의 말단이다.

---

# B+Tree

- **B+Tree**는 **B-Tree의 변형 구조**로, 데이터베이스와 파일 시스템에서 매우 자주 사용된다.
- B-Tree와 비교했을 때, B+Tree는 **범위 검색과 순차적 접근**에 최적화되어 있다.

## B+Tree의 특징:

- **데이터 저장 위치**:
    - B+Tree에서는 **모든 데이터가 리프 노드에만 저장**된다.
    - 내부 노드는 **키 값**만을 저장하고, 데이터를 저장하지 않는다.
    - 이로 인해 내부 노드는 더 많은 자식을 가질 수 있어 트리의 높이가 낮아진다.
- **범위 검색 효율성**:
    - B+Tree의 리프 노드들은 **연결 리스트**처럼 서로 연결되어 있다.
    - 따라서 **범위 검색**이나 **순차적 검색**이 매우 효율적이다.
    - 예를 들어, 특정 값 이상 또는 이하의 값을 빠르게 찾을 수 있다.
- **균형 유지**:
    - B+Tree도 B-Tree와 마찬가지로 **균형 트리**로 유지되며, 모든 리프 노드가 동일한 깊이에 위치한다.
- **사용 사례**:
    - B+Tree는 **범위 검색**이 빈번한 환경에서 매우 적합하다.
    - 데이터가 정렬된 상태로 저장되므로, **순차적 데이터 접근**이 필요한 시스템에서 자주 사용된다.
- **포인터**:
    - 리프 노드가 연결되어 있어서, 특정 범위의 데이터를 순차적으로 빠르게 검색할 수 있다.

## B+Tree의 구조:

- **내부 노드**:
    - 오직 **키 값**만을 저장하며, 데이터를 저장하지 않는다. 포인터를 통해 자식 노드를 가리킨다.
- **리프 노드**:
    - 모든 데이터를 저장하는 노드로, 리프 노드들끼리 **연결 리스트** 형태로 연결되어 있다. 리프 노드 간의 연결은 범위 검색 시 매우 유용하다.

---

# 사용사례

## **B-Tree**:

- 삽입, 삭제가 빈번하고 데이터의 정렬이 덜 중요한 경우.
- 데이터가 범위 검색보다 **정확한 값 검색**이 주된 요구 사항인 경우.

## **B+Tree**:

- **범위 검색**이 빈번한 경우.
- **순차적인 데이터 접근**이 자주 필요한 시스템에서 사용.
- 대부분의 관계형 데이터베이스(RDBMS) 및 파일 시스템에서 B+Tree를 사용하여 효율적인 인덱스 성능을 제공한다.

---

# 비교

| **특성** | **B-Tree** | **B+Tree** |
| --- | --- | --- |
| **데이터 저장 위치** | 내부 노드와 리프 노드 모두에 저장 | 리프 노드에만 저장, 내부 노드는 키만 저장 |
| **범위 검색 효율성** | 범위 검색에 비효율적 | 리프 노드가 연결되어 범위 검색에 최적화 |
| **내부 노드** | 키와 데이터를 함께 저장 | 키 값만 저장 |
| **리프 노드** | 리프 노드 간에 연결 없음 | 리프 노드가 연결되어 순차적 접근 용이 |
| **트리 높이** | 내부 노드에 데이터가 있으므로 더 높을 수 있음 | 데이터가 리프 노드에만 있어 트리 높이가 낮음 |
| **사용 사례** | 범위 검색이 덜 빈번한 경우 적합 | 범위 검색 및 순차적 접근이 필요한 경우 최적 |

---

# 정리

- **B-Tree**
    - 내부 노드와 리프 노드에 모두 데이터를 저장하여 구조가 간단하지만, **범위 검색**에는 적합하지 않다.
    - 삽입과 삭제가 자주 일어나는 환경에서 적절한 선택이 될 수 있다.
- **B+Tree**
    - **범위 검색**과 **순차적 데이터 접근**에 최적화되어 있으며, 모든 데이터를 리프 노드에만 저장하고 리프 노드 간의 연결 리스트를 사용하여 효율성을 높인다.
    - 이로 인해, B+Tree는 대규모 데이터베이스에서 인덱스 구조로 자주 사용된다.
- B+Tree는 대부분의 관계형 데이터베이스 시스템과 파일 시스템에서 **주요 인덱싱 구조**로 채택되어, 효율적인 범위 검색과 높은 성능을 제공한다.