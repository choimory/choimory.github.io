---
title: "DB 트리거(Trigger)란"
date: 2025-10-20T00:00:00
toc: true
toc_sticky: true
categories:
    - DB
tags:
    - Trigger
---

# Intro

- **DB 트리거(Trigger)**는 **특정 조건이 발생했을 때** 데이터베이스에서 **자동으로 실행되는 저장된 프로시저**이다.
- 주로 데이터 삽입, 수정, 삭제와 같은 **DML(Data Manipulation Language)** 작업이 발생할 때 자동으로 실행되며, 트리거는 데이터베이스의 **무결성 유지**와 **업무 로직 자동화**에 사용된다.
- 트리거는 **테이블 또는 뷰에 연결**되어 있으며, 데이터가 변경될 때 특정 작업을 수행할 수 있다.
- 즉, 트리거는 데이터베이스 내에서 일어나는 변화를 실시간으로 감지하여, 자동으로 정의된 작업을 수행하는 역할을 한다.

---

# 트리거의 주요 역할

## **데이터 무결성 유지**:

- 데이터가 삽입되거나 업데이트될 때, 데이터의 일관성이나 무결성을 유지하기 위해 트리거를 사용하여 자동으로 검사를 수행할 수 있다.
- 예를 들어, 특정 데이터가 삽입될 때 유효성 검사를 자동으로 수행할 수 있다.

## **자동화된 비즈니스 로직**:

- 트리거를 통해 비즈니스 규칙을 자동으로 적용할 수 있다.
- 예를 들어, 주문이 완료될 때 재고량을 자동으로 업데이트하거나, 고객의 잔액을 자동으로 조정하는 등의 작업을 트리거로 처리할 수 있다.

## **감사 및 기록(Auditing)**:

- 데이터가 변경되었을 때, 변경 전후 데이터를 기록하거나, 로그 테이블에 변경 사항을 기록하는 용도로 사용할 수 있다.
- 예를 들어, 특정 사용자가 데이터를 수정한 시간과 변경 내용을 기록하여 추적할 수 있다.

## **복잡한 참조 무결성 구현**:

- 외래키로 처리하기 어려운 복잡한 참조 무결성 제약 조건을 구현할 때 사용할 수 있다.
- 트리거는 외래키 제약 조건을 넘어서 더 세밀한 제약 조건을 자동으로 적용할 수 있다.

## **계산된 데이터 관리**:

- 데이터가 변경될 때 다른 테이블의 데이터를 자동으로 계산하고 업데이트할 수 있다.
- 예를 들어, 주문이 완료될 때 자동으로 총액을 계산하여 고객의 잔액을 갱신하는 등의 작업을 수행할 수 있다.

---

# 트리거의 구성 요소

## **이벤트(Event)**:

- 트리거가 실행되는 **상황**이다.
- 트리거는 다음과 같은 데이터 조작 이벤트에 의해 트리거될 수 있다.
    - **INSERT**: 데이터가 테이블에 삽입될 때.
    - **UPDATE**: 데이터가 수정될 때.
    - **DELETE**: 데이터가 삭제될 때.

## **조건(Condition)**:

- 트리거가 실행되기 위한 **조건**이다.
- 특정 열의 값이 변경될 때만 트리거를 실행하도록 설정할 수 있다.

## **작업(Action)**:

- 트리거가 실행될 때 수행할 **동작**이다.
- 예를 들어, 데이터를 검증하거나, 다른 테이블에 데이터를 삽입/수정/삭제하거나, 특정 로그를 남기는 작업 등이 가능하다.

---

# 트리거의 사용 시기

## **데이터 무결성 제약을 강화할 때**:

- 예를 들어, 주문이 처리되면 재고 테이블에서 해당 상품의 재고량을 감소시키는 작업을 자동으로 수행할 수 있다.

## **감사 기록을 남길 때**:

- 중요한 데이터의 변경 사항을 추적하고자 할 때, 트리거를 사용하여 변경 내용을 기록하는 로그 테이블을 관리할 수 있다.
- 예시:
    - `employees` 테이블에서 직원 정보가 업데이트되면, 이전 데이터를 기록하는 로그 테이블에 자동으로 삽입.
    
    ```sql
    CREATE TRIGGER log_employee_changes
    AFTER UPDATE ON employees
    FOR EACH ROW
    INSERT INTO employee_audit (employee_id, old_salary, new_salary, change_date)
    VALUES (OLD.employee_id, OLD.salary, NEW.salary, NOW());
    ```
    

## **연관된 데이터 동기화가 필요할 때**:

- 여러 테이블이 연관되어 있을 때, 하나의 테이블에서 데이터가 변경되면 관련된 테이블도 함께 업데이트해야 하는 경우 사용된다.

## **계산 작업을 자동화할 때**:

- 예를 들어, 데이터가 삽입될 때 자동으로 계산 작업을 수행하여 총액이나 세금 등을 계산할 수 있다.

## **복잡한 데이터 검증이 필요할 때**:

- 데이터가 입력될 때 자동으로 특정 조건을 검사하고, 조건이 맞지 않으면 오류를 발생시키거나 수정하는 용도로 사용된다.
- 예시:
    - 급여가 음수일 경우 오류를 발생시키는 트리거.
    
    ```sql
    CREATE TRIGGER check_salary
    BEFORE INSERT OR UPDATE ON employees
    FOR EACH ROW
    BEGIN
      IF NEW.salary < 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Salary cannot be negative';
      END IF;
    END;
    ```
    

---

# 트리거의 예시

## **INSERT 트리거**:

- 고객이 새로 추가될 때, 해당 정보를 감사 로그 테이블에 기록.

```sql
CREATE TRIGGER log_new_customer
AFTER INSERT ON customers
FOR EACH ROW
INSERT INTO customer_audit (customer_id, action, action_time)
VALUES (NEW.customer_id, 'INSERT', NOW());
```

## **UPDATE 트리거**:

- 직원의 급여가 업데이트될 때, 변경 전후 정보를 기록.

```sql
CREATE TRIGGER log_salary_update
AFTER UPDATE ON employees
FOR EACH ROW
INSERT INTO salary_audit (employee_id, old_salary, new_salary, change_date)
VALUES (OLD.employee_id, OLD.salary, NEW.salary, NOW());
```

## **DELETE 트리거**:

- 주문이 삭제될 때, 삭제된 주문의 정보를 별도의 테이블에 백업.

```sql
CREATE TRIGGER backup_deleted_order
BEFORE DELETE ON orders
FOR EACH ROW
INSERT INTO deleted_orders (order_id, customer_id, order_date)
VALUES (OLD.order_id, OLD.customer_id, OLD.order_date);
```

---

# 장점

- **자동화**:
    - 트리거는 테이블에 대한 조작이 발생할 때 자동으로 실행되므로, **반복적인 작업**을 자동화할 수 있다.
- **데이터 무결성 유지**:
    - 데이터 입력, 수정, 삭제 시 자동으로 **데이터 무결성**을 유지하는 작업을 수행할 수 있다.
- **감사와 모니터링**:
    - 데이터 변경 사항을 자동으로 기록할 수 있어, 변경 내역을 추적할 수 있다.
- **비즈니스 로직 적용**:
    - 특정 비즈니스 로직을 데이터베이스 레벨에서 직접 적용할 수 있어 애플리케이션 코드와 분리된 처리도 가능하다.

# 단점

- **성능 저하**:
    - 트리거가 과도하게 사용되면, 데이터 변경 시마다 추가 작업이 발생하여 성능이 저하될 수 있다.
- **디버깅 어려움**:
    - 트리거는 **자동으로 실행**되므로, 버그가 발생할 경우 원인을 찾기가 어려울 수 있다.
- **복잡성 증가**:
    - 여러 트리거가 서로 얽히면 데이터 흐름을 추적하기 어려워지고, 유지보수가 복잡해질 수 있다.
- **의도하지 않은 실행**:
    - 트리거는 데이터 변경 시 자동으로 실행되므로, 의도하지 않은 작업이 발생할 수 있다.

# 주의점

- **성능 고려**:
    - 트리거가 너무 자주 실행되거나, 트리거 내부에서 복잡한 작업을 수행하면 성능이 저하될 수 있으므로 주의해야 한다.
- **비즈니스 로직과의 분리**:
    - 중요한 비즈니스 로직은 애플리케이션 계층에서 처리하는 것이 더 관리하기 쉬울 수 있다. 트리거는 데이터 무결성 유지 등 데이터베이스 레벨에서만 처리할 수 있는 부분에 사용하는 것이 좋다.
- **의도하지 않은 상호작용**:
    - 여러 트리거가 동시에 작동할 때, 예기치 않은 상호작용으로 인한 문제를 방지하기 위해 트리거 간의 연관성을 명확히 이해해야 한다.

# 정리

- *트리거(Trigger)*는 데이터베이스 내에서 자동으로 실행되는 프로시저로, **데이터 무결성 유지**, **자동화된 비즈니스 로직 처리**, **감사 기록** 등 다양한 용도로 사용된다.
- 적절히 사용하면 매우 강력한 도구가 될 수 있지만, 과도한 사용이나 복잡한 트리거 로직은 성능 저하와 유지보수 어려움의 원인이 될 수 있으므로 신중하게 설계해야 한다.