---
title: "커맨드로 사용하는 git"
date: 2025-08-25T00:00:00
toc: true
toc_sticky: true
categories:
    - Back-end
tags:
    - Git
---

# log

- `git log —oneline —all` 모든 깃 내역을 확인한다
- `git log —oneline —graph —all` 모든 깃 내역을 그래프로 확인한다

| **옵션** | **설명** |
| --- | --- |
| --oneline | 커밋 한 줄로 요약 (커밋해시 메시지) |
| --graph | 브랜치 구조를 그래픽 형태로 표시 |
| --decorate | 커밋 옆에 브랜치 이름이나 태그 표시 |
| --all | 현재 브랜치뿐 아니라 모든 브랜치 포함해서 로그 표시 |
| -n <숫자> | 최근 n개의 커밋만 출력 |
| --author="이름" | 특정 작성자의 커밋만 필터링 |
| --grep="키워드" | 커밋 메시지에 특정 문자열 포함된 커밋만 |
| --since="날짜" / --until="날짜" | 특정 기간 동안의 커밋만 |
| --stat | 파일별 변경사항 간략 요약 표시 |
| -p | 커밋된 실제 diff 내용까지 출력 |
| --name-only | 변경된 파일 목록만 표시 |
| --reverse | 오래된 커밋부터 출력 |

# checkout

- `git checkout <branch_name>` 브랜치를 전환한다
- `git checkout -b <branch_name>` 새 로컬 브랜치를 생성한다

| **명령어** | **설명** |
| --- | --- |
| git checkout main | main 브랜치로 전환 |
| git checkout -b feature/login | 현재 브랜치 기준 새 브랜치 생성 후 전환 |
| git checkout -b hotfix/login bugfix/login | bugfix/login 브랜치를 기준으로 새 브랜치 생성 |
| git checkout 1a2b3c4 | 특정 커밋 기준으로 워킹 디렉토리를 detached HEAD로 전환 |
| git checkout HEAD -- <파일> | 수정한 파일을 마지막 커밋 상태로 되돌림 |
| git checkout <브랜치> -- <파일> | 다른 브랜치에 있는 파일만 가져오기 |

# branch

- `git branch`: 로컬 브랜치 목록
- `git branch -r`: 원격 브랜치 목록
- `git branch -a`: 모든 브랜치 목록
- `git branch -d <branch_name>`: 특정 브랜치 삭제
- `git branch -D <branch_name>`: 특정 브랜치 강제 삭제

| 명령어 | 설명 |
| --- | --- |
| `git branch` | 현재 로컬 브랜치 목록 조회 |
| `git branch -a` | 전체 브랜치 목록 (로컬 + 원격) 조회 |
| `git branch -r` | 원격 브랜치 목록만 조회 |
| `git branch -vv` | 로컬 브랜치 + 원격 추적 정보 표시 |
| `git branch <브랜치명>` | 새 브랜치 생성 (현재 브랜치 기준) |
| `git branch <브랜치명> <기준>` | 특정 커밋/브랜치 기준으로 새 브랜치 생성 |
| `git branch -m <새이름>` | 현재 브랜치 이름 변경 |
| `git branch -m <기존> <새이름>` | 특정 브랜치 이름 변경 |
| `git branch -d <브랜치명>` | 브랜치 삭제 (병합된 경우만 허용) |
| `git branch -D <브랜치명>` | 브랜치 강제 삭제 |
| `git push origin <브랜치명>` | 로컬 브랜치를 원격으로 푸시 |
| `git push origin --delete <브랜치명>` | 원격 브랜치 삭제 |
| `git branch --set-upstream-to=origin/<브랜치명>` | 로컬 브랜치에 원격 추적 브랜치 설정 |

# add

- `git add <file_path/file_name>`: unstaged된 파일을 staged함
- `git add .`: 현재 디렉토리 내의 변경사항을 staged함
- `git add -A`: 모든 변경사항을 staged함

| 명령어 | 설명 |
| --- | --- |
| `git add <파일>` | 특정 파일만 스테이지에 올림 |
| `git add .` | 현재 디렉토리 **모든 변경사항(신규, 수정)** 스테이지에 추가 |
| `git add -A` | 모든 변경사항(신규, 수정, 삭제) 스테이지에 반영 |
| `git add -u` | **추적 중인 파일들**의 수정/삭제만 스테이지에 반영 (신규 파일 제외) |
| `git add -p` | 변경된 내용을 **부분적으로 선택**하여 스테이지에 올림 (인터랙티브) |
| `git add -n` | 실제로 추가하지 않고 어떤 파일이 추가될지 **미리 보기(dry-run)** |
| `git add -v` | 어떤 파일이 스테이징되는지 **자세히 출력** |
| `git add --intent-to-add <파일>` | 추적되지 않은 파일을 "추적 예정" 상태로 표시 (diff 확인용) |
| `git add -i` | **인터랙티브 모드**로 파일/변경 선택 (텍스트 UI 제공) |

# restore

- git 2.23으로 추가된 기능으로, 이전에 git reset으로 하던 기능을 명확히 하기 위해 restore 명령어에도 추가함

| 명령어 | 설명 |
| --- | --- |
| `git restore <파일>` | 워킹 디렉토리에서 변경된 파일을 최신 커밋 상태(HEAD)로 되돌림 |
| `git restore --staged <파일>` | 스테이징 영역에서 해당 파일 제거 (워킹 디렉토리는 그대로) |
| `git restore --source=<커밋>` <파일> | 특정 커밋 기준으로 파일 복원 (`HEAD`, `HEAD~1`, 커밋 해시 등) |
| `git restore --worktree <파일>` | 워킹 디렉토리만 복원 (명시적으로 지정 가능) |
| `git restore --staged --worktree <파일>` | 스테이지와 워킹 디렉토리 모두 복원 |
| `git restore -s <커밋>` <파일> | `--source` 줄임말, 특정 커밋 기준으로 복원 |
| `git restore --patch <파일>` | 인터랙티브하게 변경된 부분만 선택해서 복원 |

| 목적 | 명령어 |
| --- | --- |
| 로컬 수정 파일 되돌리기 | `git restore app.kt` |
| 스테이지에서 제거만 (add 취소) | `git restore --staged app.kt` |
| 둘 다 되돌리기 (reset처럼) | `git restore --staged --worktree app.kt` |
| 이전 커밋 기준으로 파일 복원 | `git restore --source=HEAD~1 app.kt` |
| 변경 중 일부만 선택해서 되돌리기 | `git restore --patch app.kt` |

| 동작 | 명령어 |
| --- | --- |
| 워킹 디렉토리 되돌리기 | `git restore <파일>` |
| 스테이징 제거 | `git restore --staged <파일>` |
| 둘 다 | `git restore --staged --worktree <파일>` |
| 예전 방식 | `git checkout -- <파일>` / `git reset <파일>` |

# commit

- `git commit -m “커밋 메시지”`: 메시지와 함께 커밋
- `git commit -a`: staged된 모든 파일을 커밋
- `git commit -am “커밋 메시지”`: staged된 모든 파일을 메시지와 함께 커밋

| 명령어 | 설명 |
| --- | --- |
| `git commit` | 기본 커밋 (에디터 열림) |
| `git commit -m "메시지"` | 커밋 메시지를 인라인으로 작성 |
| `git commit -am "메시지"` | **수정된 추적 파일(add 포함)**을 한 번에 커밋 (신규 파일은 포함 안 됨) |
| `git commit --amend` | 이전 커밋 수정 (메시지 or 내용 추가/변경) |
| `git commit --no-edit` | `--amend` 시 기존 커밋 메시지 유지 |
| `git commit --allow-empty` | 변경 사항 없이 커밋 생성 (로그 이벤트용 등) |
| `git commit --dry-run` | 커밋 없이 어떤 파일이 커밋될지 확인만 |
| `git commit -v` | 커밋 시 diff 출력 (커밋 메시지 에디터에 표시됨) |
| `git commit --author="이름 <이메일>"` | 다른 작성자로 커밋 |
| `git commit --date="YYYY-MM-DD HH:MM:SS"` | 커밋 시간 수동 지정 |
| `git commit -S -m "메시지"` | GPG 서명 포함 커밋 (`-S`: sign) |

# push

- `git push`: 현재 브랜치 푸쉬
- `git push <branch_name>`: 특정 브랜치 푸쉬

| 명령어 | 설명 |
| --- | --- |
| `git push` | 현재 브랜치를 기본 원격(origin)에 푸시 |
| `git push origin <브랜치>` | 특정 브랜치를 origin에 푸시 |
| `git push -u origin <브랜치>` | 원격 브랜치와 로컬 브랜치 연결 (추후 `git push`만 써도 됨) |
| `git push origin <로컬>:<원격>` | 로컬 브랜치를 원격의 다른 이름으로 푸시 |
| `git push origin --delete <브랜치>` | 원격 브랜치 삭제 |
| `git push --tags` | 태그 전부 푸시 |
| `git push origin <태그>` | 특정 태그만 푸시 |
| `git push --force` (`-f`) | 강제 푸시 (주의: 히스토리 덮어씀) |
| `git push --force-with-lease` | **더 안전한 강제 푸시** (원격 변경이 없을 때만 강제) |
| `git push --dry-run` | 실제로 푸시하지 않고 어떤 게 푸시될지 확인만 |
| `git push origin HEAD` | 현재 브랜치를 원격에 같은 이름으로 푸시 |
| `git push origin HEAD:<원격브랜치>` | 현재 브랜치를 원격의 특정 브랜치로 푸시 |

# pull

- `git pull`: 현재 브랜치의 최신사항 업데이트
- `git pull origin <branch_name>`: 특정 원격 브랜치 내용 업데이트
- `tmi1`: `git pull`은 사실 `git fetch`+`git merge`이다
- `tmi2`: `git pull —rebase`는 `git fetch` 후 `git merge` 대신 `git rebase`한다

| 명령어 | 설명 |
| --- | --- |
| `git pull` | 원격의 기본 브랜치를 가져와 현재 브랜치에 병합 |
| `git pull origin <브랜치>` | origin에서 특정 브랜치를 현재 브랜치에 병합 |
| `git pull --rebase` | fetch 후 rebase 수행 (병합 커밋 없이 깔끔한 기록 유지) |
| `git pull --no-commit` | 병합은 하지만 자동 커밋하지 않음 |
| `git pull --no-ff` | 병합 시 Fast-forward 금지 (항상 merge commit 생성) |
| `git pull --ff-only` | Fast-forward만 허용, 병합 커밋 금지 |
| `git pull --all` | 모든 원격 저장소의 브랜치 fetch (병합은 안 함) |
| `git pull --verbose` | 상세한 fetch/merge 정보 출력 |
| `git pull --no-rebase` | rebase 대신 merge 사용 (기본값) |
| `git pull --recurse-submodules` | 서브모듈 포함해서 pull |

# fetch

- `git fetch`: 새로고침

| **명령어** | **설명** |
| --- | --- |
| git fetch | 기본 원격(origin)의 모든 브랜치와 태그 가져오기 |
| git fetch origin | origin의 모든 브랜치/태그 가져오기 (명시적) |
| git fetch origin <브랜치> | 특정 브랜치만 가져오기 |
| git fetch --all | 모든 원격 저장소의 변경사항 가져오기 |
| git fetch --prune | 원격에서 삭제된 브랜치를 로컬에서도 제거 |
| git fetch --tags | 원격 태그만 가져오기 |
| git fetch --depth=<n> | n개 커밋만 가져오는 **shallow clone** 방식 (속도↑) |
| git fetch --dry-run | 실제 fetch하지 않고 가져올 변경사항만 출력 |
| git fetch -v | verbose 모드, 어떤 게 fetch됐는지 상세 출력 |
| git fetch origin <원격브랜치>:<로컬브랜치> | 원격 브랜치 변경사항을 로컬 브랜치에 업데이트 |
| git fetch --recurse-submodules | 서브모듈 포함해서 fetch |

| **작업** | **명령어** |
| --- | --- |
| 전체 최신 변경사항만 가져오기 | git fetch |
| 특정 브랜치만 가져오기 | git fetch origin dev |
| 원격 브랜치 삭제 동기화 | git fetch --prune |
| 태그만 가져오기 | git fetch --tags |
| 삭제된 원격 브랜치 정리까지 포함 | git fetch --all --prune |
| 어떤 게 변경됐는지만 보기 | git fetch --dry-run |
- `git fetch origin <원격브랜치>:<로컬브랜치>`는 내 현재 브랜치 외에 다른 브랜치만 가능함 
(dev일때 git fetch origin dev:dev 불가능)

# merge

- `git merge <branch_name>`: 특정 브랜치를 현재 브랜치에 merge

| **명령어** | **설명** |
| --- | --- |
| git merge <브랜치> | 현재 브랜치에 <브랜치>를 병합 |
| git merge --no-ff | 병합 커밋을 항상 생성 (fast-forward 방지) |
| git merge --ff-only | fast-forward 병합만 허용 (커밋 기록 깔끔하게 유지) |
| git merge --squash <브랜치> | 병합은 하되, 커밋은 하나로 합쳐서 stage (직접 커밋 필요) |
| git merge --abort | 병합 도중 충돌 발생 시 병합 취소 |
| git merge --commit | 자동 커밋 수행 (기본 동작) |
| git merge --no-commit | 병합만 하고 커밋하지 않음 (리뷰 후 커밋하고 싶을 때) |
| git merge -m "메시지" | 커밋 메시지를 명시적으로 지정 |
| git merge --strategy=<전략> | 병합 전략 선택 (예: recursive, ours, theirs |

| **작업** | **명령어** |
| --- | --- |
| develop에 feature/login 병합 | git checkout develop && git merge feature/login |
| 항상 병합 커밋 남기기 | git merge --no-ff feature/login |
| 병합 충돌 후 롤백 | git merge --abort |
| 여러 커밋을 하나로 합쳐 병합 | git merge --squash feature/login → git commit -m "..." |
| fast-forward만 허용 | git merge --ff-only feature/login |
| 병합만 하고 커밋은 나중에 | git merge --no-commit feature/login |

# rebase

- `git rebase <branch_name>`: 특정 브랜치를 현재 브랜치 밑으로 깔아서 병합함
- `rebase`는 conflict시 내역을 하나하나 확인하며 병합해줘야함. 귀찮지만 꼼꼼히 확인하는 과정이기도 함
- `git push --force-with-lease`: rebase는 강제푸시해야할 수 있음

| **명령어** | **설명** |
| --- | --- |
| git rebase <브랜치> | 현재 브랜치를 <브랜치> 위로 옮김 (일반적인 사용) |
| git rebase -i <기준> | **인터랙티브 리베이스** (커밋 순서, 메시지, 병합, 삭제 등 편집 가능) |
| git rebase --continue | 충돌 해결 후 리베이스 계속 진행 |
| git rebase --abort | 충돌 시 리베이스 전체 취소 |
| git rebase --skip | 현재 충돌 커밋 건너뜀 |
| git rebase --onto <새기반> <시작점> <브랜치> | 복잡한 리베이스 (커밋 일부만 옮기기 등) |
| git rebase --autostash | 리베이스 전에 변경사항 자동 임시 저장 후 복원 |
| git rebase --keep-empty | 빈 커밋 유지 |
| git rebase --root | 프로젝트 초기부터 리베이스 시작 (전체 커밋 수정 가능) |

| **작업** | **명령어** |
| --- | --- |
| 내 브랜치를 최신 develop 위로 올리기 | git checkout feature → git rebase develop |
| 최근 3개 커밋 정리 (squash, 메시지 변경 등) | git rebase -i HEAD~3 |
| 리베이스 도중 충돌 해결 후 계속 | git rebase --continue |
| 리베이스 중단하고 원상복구 | git rebase --abort |
| 커밋 기반 변경 (특정 커밋만 이동) | git rebase --onto main dev~3 dev |

# reset

- `reset`은 보통 로컬에 commit만 된 내역을 날려버리는 기능임
- `git reset hard <commit_hash>`: 해당 내역으로 리셋함

| **명령어** | **설명** |
| --- | --- |
| git reset | 기본은 --mixed와 동일 |
| git reset --soft <커밋> | HEAD를 이동만 함 (스테이징과 작업 내용은 그대로) |
| git reset --mixed <커밋> | HEAD + 스테이징만 변경 (작업 디렉토리는 유지) ← 기본 동작 |
| git reset --hard <커밋> | HEAD + 스테이징 + 작업 디렉토리 전부 되돌림 (주의: 변경사항 삭제됨) |
| git reset <파일> | 특정 파일만 스테이징에서 제거 (작업 내용은 유지) |
| git reset HEAD~1 | 마지막 커밋을 취소 (스테이징으로 되돌림) |
| git reset --keep <커밋> | 작업 중 변경사항은 보존하며 커밋만 되돌림 (충돌 시 실패) |
| git reset --merge <커밋> | 병합 충돌 중단 후 복구용 (특수상황) |

| **작업 목적** | **명령어** |
| --- | --- |
| 최근 커밋 취소 + 작업 유지 | git reset --soft HEAD~1 |
| git add 취소 (스테이지만 제거) | git reset <파일> |
| 커밋 + 스테이지 취소 (작업 디렉토리 유지) | git reset --mixed HEAD~1 |
| 모든 것 삭제하고 되돌림 (주의!) | git reset --hard HEAD~1 |
| 특정 커밋으로 완전 초기화 | git reset --hard <커밋해시> |
| 변경사항 보존하며 되돌리기 | git reset --keep HEAD~2 |

| **모드** | **HEAD** | **스테이지(Index)** | **작업 디렉토리(Working Dir)** | **사용 목적** |
| --- | --- | --- | --- | --- |
| --soft | O | 유지 | 유지 | 커밋만 취소하고 다시 커밋하고 싶을 때 |
| --mixed | O | 초기화 | 유지 | git add를 취소하고 다시 고치고 싶을 때 |
| --hard | O | 초기화 | 초기화 | **모든 변경사항 제거**하고 되돌리고 싶을 때 (주의) |

# revert

- `revert`는 보통 원격까지 push된 작업사항에 반대되는 내역을 다시 push하여 실질적으로 원복하는 기능임
- 보통 원격까지 올라간 경우에 reset이 안되므로 revert함
- `git revert <commit_hash>`: 특정지점까지 변경된 작업사항을 되돌리는 내역을 다시 push함
- `git revert <commit_hash> -m "Revert msg"`: 메시지와 함께 revert한 내역을 push함

| **명령어** | **설명** |
| --- | --- |
| git revert <커밋해시> | 해당 커밋을 되돌리는 새 커밋 생성 |
| git revert HEAD | 가장 최근 커밋 되돌리기 |
| git revert HEAD~2 | 세 번째 이전 커밋 되돌리기 |
| git revert <해시1>..<해시2> | 여러 커밋 한꺼번에 되돌리기 (해시2는 **포함 안됨**) |
| git revert --no-commit <커밋해시> | revert 결과를 커밋하지 않고 stage 상태로 둠 |
| git revert --edit <커밋해시> | 커밋 메시지 수정 가능 (기본값) |
| git revert --no-edit <커밋해시> | revert 커밋 메시지를 자동으로 사용 |
| git revert --abort | revert 중 충돌 발생 시 작업 취소 |

| **작업** | **명령어** |
| --- | --- |
| 가장 최근 커밋 되돌리기 | git revert HEAD |
| 특정 커밋 되돌리기 | git revert a1b2c3d |
| 여러 커밋 되돌리기 | git revert HEAD~3..HEAD |
| revert 결과만 보고 싶을 때 | git revert --no-commit <커밋> |
| 충돌 발생 시 취소 | git revert --abort |

| **항목** | git revert | git reset |
| --- | --- | --- |
| 커밋 기록 | 보존함 (되돌리는 새 커밋 생성) | 삭제 또는 덮어씀 |
| 협업 안전성 | 안전 (공유 브랜치에 적합) | 위험 (강제 푸시 필요) |
| 사용 상황 | 실수 커밋 취소하면서 히스토리 유지 | 커밋을 없던 것처럼 만들고 싶을 때 |

# reflog

- git reflog는 Git에서 HEAD(현재 커밋 위치)의 이동 이력을 추적하는 명령어
- reset, rebase, commit, checkout 등을 통해 커밋을 바꿨더라도 로컬에서는 되돌릴 수 있는 복구 히스토리를 보여줌

| **명령어** | **설명** |
| --- | --- |
| git reflog | HEAD 이동 이력 전체 출력 |
| git reflog show | 기본 HEAD의 reflog 보기 (동일함) |
| git reflog <브랜치> | 특정 브랜치의 HEAD 이동 이력 확인 |
| git reflog --date=iso | 날짜를 ISO 포맷으로 출력 |
| git reflog --grep=<키워드> | 메시지에 특정 문자열 포함된 항목만 필터링 |
| git reflog expire --expire=now --all | 모든 브랜치의 reflog 기록 즉시 삭제 (주의!) |
| git reflog delete <항목> | 특정 항목만 reflog에서 삭제 (거의 안 씀) |

| **작업** | **명령어** |
| --- | --- |
| HEAD 이동 이력 보기 | git reflog |
| 이전 커밋 위치로 되돌리기 | git reset --hard HEAD@{2} |
| 커밋 덮어썼을 때 복구 | git reflog → 해시 확인 후 git reset |
| 특정 브랜치의 이동 이력 | git reflog develop |
| 최근 rebase 전 위치 복구 | git reset --hard ORIG_HEAD |

# stash

- git stash는 현재 작업 중인 변경사항(수정된 파일, 스테이징된 파일 포함)을 임시 저장하고 워킹 디렉토리를 깔끔한 상태로 만들 때 사용
- 브랜치 전환 전이나 실험 작업 중 잠깐 보관하고 싶을 때 유용

| **명령어** | **설명** |
| --- | --- |
| git stash | 변경사항(수정 + staged) 임시 저장 |
| git stash save "메시지" | stash에 이름 붙이기 (구버전 방식, 최신 Git에서는 생략 가능) |
| git stash push -m "메시지" | stash에 메시지를 붙이고 저장 |
| git stash list | 저장된 stash 목록 보기 |
| git stash show | 가장 최근 stash 변경 요약 |
| git stash show -p | 가장 최근 stash의 상세 diff 보기 |
| git stash apply | 가장 최근 stash 복원 (stash는 그대로 유지) |
| git stash apply stash@{n} | n번째 stash 복원 |
| git stash pop | stash 복원 후 목록에서 삭제 |
| git stash drop stash@{n} | 특정 stash 삭제 |
| git stash clear | 모든 stash 제거 |
| git stash -u 또는 --include-untracked | 추적되지 않은 파일도 stash에 포함 |
| git stash -a 또는 --all | .gitignore 포함 모든 파일 stash |

# tag

- `git tag`: 목록 확인
- `git tag <tag_name>`: 태그 생성
- `git push <tag_name>`: 태그 push
- `git push --tags`: 태그 전체 푸쉬

| **명령어** | **설명** |
| --- | --- |
| git tag | 모든 태그 목록 조회 |
| git tag <태그명> | 현재 커밋에 태그 생성 (lightweight 태그) |
| git tag -a <태그명> -m "메시지" | 주석(tag message)이 포함된 **annotated 태그** 생성 |
| git tag <태그명> <커밋해시> | 특정 커밋에 태그 생성 |
| git show <태그명> | 태그가 가리키는 커밋 상세 보기 |
| git tag -d <태그명> | 로컬 태그 삭제 |
| git push origin <태그명> | 특정 태그를 원격에 푸시 |
| git push origin --tags | 모든 태그를 원격에 푸시 |
| git push origin :refs/tags/<태그명> | 원격 태그 삭제 |
| git tag -n | 태그 목록 + 메시지 요약 보기 |
| git tag -l "v1.*" | 이름 패턴으로 태그 필터링 |

# git flow

- `git flow init`: 해당 프로젝트의 첫 git flow 설정 (해당 프로젝트 디렉토리 내에서)
- `git flow init -f`: 기존 세팅 무시하고 처음부터 다시 세팅 (해당 프로젝트 디렉토리 내에서)
- `git flow release start <branch_name>`: 배포용 브랜치 생성
- `git flow release finish <branch_name>`: 배포용 브랜치를 운영 브랜치에 병합하고 태그를 생성 
(로컬에만 생성하므로 이후 운영 브랜치와 태그의 푸시가 필요함)
- `git flow hotfix start <branch_name>`: 핫픽스용 브랜치 생성
- `git flow hotfix finish <branch_name>`: 핫픽스용 브랜치를 운영 브랜치에 병합하고 태그를 생성 (로컬에만 생성하므로 이후 운영 브랜치와 태그의 푸시가 필요함)