---
title: "백엔드 아키텍쳐의 구조"
date: 2025-08-09T00:00:00
toc: true
toc_sticky: true
categories:
    - Back-end
tags:
    - MSA
    - API
---

# 백엔드 아키텍쳐의 구조

- 시작은 하나의 큰 코드베이스로 구성된 **모놀리틱 아키텍처**였으며, 배포 주기와 확장성의 어려움을 겪으면서 도메인별로 서비스가 분리되고 **마이크로서비스** 형태로 진화
- 하지만 서비스는 나뉘어도 데이터베이스는 여전히 공유되면서 커플링 문제가 발생하고, 이를 해결하기 위해 각 마이크로서비스가 독립적인 데이터베이스를 가지는 구조로 변경
- 이후 통신량 증가로 인한 레이턴시 문제를 해결하기 위해 **RPC(gRPC)** 통신이 도입되고, 이 역시 서비스 간의 강한 의존성을 야기하자 이를 완화하기 위해 **이벤트 드리븐 아키텍처**가 사용됩니다. 이 아키텍처에서는 서비스들이 이벤트를 발행하고, 이를 다른 서비스들이 비동기적으로 구독함으로써 느슨한 결합을 구현함
- 그러나 분산 환경에서는 트랜잭션 관리가 어려워지고, 이 문제를 해결하기 위해 **사가 패턴(Saga Pattern)**이 등장합니다. 이는 서비스 간의 연쇄 작업을 하나의 트랜잭션처럼 묶고, 문제가 생길 경우 보상 작업을 통해 롤백을 수행함
- 운영이 복잡해지면서 **CQRS(Command Query Responsibility Segregation)**가 도입되어, 데이터 생성과 조회의 역할을 분리하고 각각의 목적에 맞는 최적화된 데이터 저장 방식이 사용됨
- 클라이언트가 복잡한 마이크로서비스에 직접 접근하는 문제는 **API 게이트웨이**로 해결되며, 마이크로서비스 간의 장애 전파를 막기 위한 **서킷 브레이커 패턴**도 적용함
- 마지막으로, 모든 마이크로서비스를 효과적으로 운영하기 위해 **오케스트레이션 도구(예: Kubernetes)**가 사용되며, 이는 마치 지휘자처럼 전체 시스템의 건강한 운영을 책임짐

# **아키텍처 구조의 변화**

## **모놀리틱 아키텍처**

- 하나의 코드베이스, 하나의 배포 단위
- 전체 시스템을 동시에 배포/스케일링해야 함

## **마이크로서비스 아키텍처**

- 도메인별로 서비스 분리
- 독립 배포 및 확장 가능
- 초기에는 DB는 공유 → 이후 DB도 서비스별로 분리

---

# **통신 방식**

## **HTTP (기본 REST API)**

- 쉬운 구현이 장점이나, 네트워크 레이턴시와 병목 발생

## **gRPC (RPC 방식)**

- 빠르고 경량화된 바이너리 기반 통신
- 낮은 레이턴시, 하지만 강한 커플링 발생

## **이벤트 드리븐 아키텍처**

- 이벤트 발행 후 “잊어버림” → 구독자가 비동기 처리
- 서비스 간 결합도 감소

---

# **데이터 및 트랜잭션 처리**

## **사가 패턴 (Saga Pattern)**

- 분산된 서비스 간 트랜잭션을 보상 트랜잭션으로 처리
- 중간 장애 시 롤백 가능

## **CQRS (Command Query Responsibility Segregation)**

- 읽기(조회)와 쓰기(생성/수정)를 분리
- 성능 최적화 및 확장성 향상

---

# **서비스 연결과 관리**

## **API 게이트웨이**

- 클라이언트 요청을 단일 진입점으로 받아 라우팅
- 인증, 로깅, 라우팅, 속도 제한 등 가능

## **서킷 브레이커 패턴**

- 한 서비스의 장애가 전체로 전파되는 것을 방지
- 일정 실패율 이상 시 회로를 끊고 fallback 처리

## **오케스트레이션 (Kubernetes 등)**

- 마이크로서비스를 자동 배포, 확장, 복구
- 서비스 운영의 자동화

---

- 각 개념은 단독으로 사용되기보단, **MSA를 구현하고 운영하는 데 필요한 도구와 설계의 일부로 조합**되어 사용됨