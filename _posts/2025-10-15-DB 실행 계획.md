---
title: "DB 실행 계획"
date: 2025-10-15T00:00:00
toc: true
toc_sticky: true
categories:
    - DB
tags:
    - explain
---

# DB 실행 계획

- 실행 계획(Execution Plan)은 데이터베이스 관리 시스템(DBMS)이 특정 쿼리를 처리하기 위해 선택한 **최적의 실행 경로**를 의미한다.
- 실행 계획은 쿼리의 처리 방식, 데이터 접근 방식(인덱스 사용 여부 등), 조인 순서, 조인 방법 등을 보여주며, 쿼리가 실행되는 동안 DBMS가 어떤 경로로 데이터를 가져오는지에 대한 구체적인 정보를 제공한다.
- 이를 통해 쿼리가 어떻게 처리되는지 분석하고, **성능 병목 현상**을 찾아내어 쿼리 최적화를 할 수 있다.

---

# 스캔 종류

## **풀 테이블 스캔 (Full Table Scan)**

- 테이블의 모든 행을 처음부터 끝까지 읽는 방식이다.
- 특정 조건에 맞는 데이터를 찾기 위해 **전체 테이블을 순차적으로 탐색**한다.
- **특징**:
    - 테이블의 행 수가 많을수록 성능에 악영향을 미친다.
    - 인덱스가 없거나, 쿼리에서 인덱스를 사용할 수 없는 경우 발생한다.
    - 작은 테이블에서는 풀 테이블 스캔이 인덱스를 사용하는 것보다 빠를 수 있다.
- **최적화 방법**:
    - 적절한 인덱스를 생성하거나, 쿼리를 조정하여 인덱스를 사용할 수 있도록 한다.
- **예시**:
    
    ```sql
    SELECT * FROM customers WHERE last_name = 'Smith';
    ```
    
    - 이 쿼리가 `last_name` 컬럼에 인덱스가 없을 경우, 풀 테이블 스캔이 발생할 수 있다.

## **인덱스 스캔 (Index Scan)**

- 인덱스를 사용해 데이터를 읽어오는 방식으로, 인덱스의 **모든 항목**을 순차적으로 스캔한다.
- 인덱스에 포함된 모든 값을 읽어야 할 때 사용된다.
- **특징**:
    - 인덱스 자체가 크면, 인덱스 스캔은 성능 저하를 유발할 수 있다.
    - 범위 조건이나, 전체 인덱스를 스캔해야 하는 쿼리에서 사용된다.
    - 주로 **비트맵 인덱스**나 **비트맵 조인**에서 많이 발생한다.
- **예시**:
    
    ```sql
    SELECT * FROM customers WHERE last_name > 'A';
    ```
    
    - 이 쿼리는 `last_name` 컬럼에 인덱스가 있으면 인덱스 스캔을 통해 데이터를 가져온다.

## **인덱스 탐색 (Index Seek)**

- 인덱스를 사용해 **특정 값을 가진 데이터**를 찾는 방식이다.
- 인덱스 트리를 탐색하여 해당 값이나 좁은 범위에 속하는 데이터를 빠르게 찾아낸다.
- **특징**:
    - **정확한 값**을 검색하거나, **좁은 범위**의 값을 찾을 때 사용된다.
    - 인덱스 탐색은 **가장 빠른 방식** 중 하나로, 검색 성능을 크게 향상시킨다.
    - 인덱스가 잘 설계된 경우, 대규모 데이터에서도 효율적인 검색이 가능하다.
- **예시**:
    
    ```sql
    SELECT * FROM orders WHERE order_id = 12345;
    ```
    
    - `order_id` 컬럼에 인덱스가 있으면, 해당 쿼리는 인덱스 탐색을 통해 정확한 데이터를 빠르게 찾는다.

## **인덱스 전 범위 스캔 (Index Full Scan)**

- 인덱스의 모든 항목을 **순차적으로 스캔**하는 방식이다.
- 특정 범위가 아닌, 인덱스에 있는 모든 데이터를 읽을 때 사용된다.
- **특징**:
    - 인덱스가 정렬된 순서대로 스캔되기 때문에 `ORDER BY`나 `GROUP BY`를 사용할 때 유용하다.
    - **모든 인덱스**를 스캔해야 할 경우 사용된다.
    - 인덱스 자체가 작거나 효율적일 때는 사용될 수 있다.
- **예시**:
    
    ```sql
    SELECT * FROM customers ORDER BY last_name;
    ```
    
    - `last_name`에 인덱스가 있을 경우, 인덱스 전 범위 스캔을 통해 데이터를 정렬하여 가져온다.

## **인덱스 범위 스캔 (Index Range Scan)**

- 인덱스의 특정 **범위**를 스캔하는 방식이다.
- 인덱스를 사용해 데이터의 시작 지점을 찾고, 그 지점부터 조건에 맞는 범위의 데이터를 순차적으로 읽어들인다.
- **특징**:
    - 범위 검색이나, `BETWEEN`, `>=`, `<=` 같은 조건을 사용할 때 발생한다.
    - 대규모 데이터에서 특정 범위의 데이터를 효율적으로 읽어낼 수 있다.
- **예시**:
    
    ```sql
    SELECT * FROM orders WHERE order_date BETWEEN '2023-01-01' AND '2023-01-31';
    ```
    
    - `order_date`에 인덱스가 있으면, 해당 범위를 기준으로 인덱스 범위 스캔이 수행된다.

## **인덱스 스킵 스캔 (Index Skip Scan)**

- 인덱스의 **첫 번째 컬럼**을 사용하지 않고, 두 번째 이후의 컬럼을 기준으로 인덱스를 스캔하는 방식이다.
- 인덱스 스킵 스캔은 다중 컬럼 인덱스에서 발생하며, 첫 번째 컬럼이 조건에 없더라도 인덱스의 나머지 컬럼을 사용해 데이터를 검색할 수 있다.
- **특징**:
    - 다중 컬럼 인덱스에서 첫 번째 컬럼이 조건에 없을 때 사용된다.
    - 효율성이 떨어질 수 있으므로, 사용에 주의가 필요하다.
- **예시**:
    
    ```sql
    SELECT * FROM employees WHERE department_id = 10;
    ```
    
    - `employee_id, department_id`로 된 인덱스에서, 첫 번째 컬럼을 건너뛰고 `department_id`를 기준으로 인덱스 스킵 스캔이 수행될 수 있다.

## **테이블 액세스 BY ROWID (Table Access By ROWID)**

- 인덱스를 사용해 검색한 후, 실제 데이터를 ROWID(행의 고유 식별자)를 통해 테이블에서 검색하는 방식이다.
- 인덱스를 통해 찾은 행의 위치를 알아내고, 해당 위치에서 데이터를 가져온다.
- **특징**:
    - 인덱스를 사용한 후, 실제 데이터를 가져오기 위해 발생하는 최종 데이터 접근 방식.
- **예시**:
    
    ```sql
    SELECT * FROM employees WHERE employee_id = 101;
    ```
    
    - `employee_id`에 인덱스가 있으면, 인덱스 탐색 후 ROWID를 통해 데이터를 읽는다.

## **비트맵 인덱스 스캔 (Bitmap Index Scan)**

- **비트맵 인덱스**를 사용해 데이터를 스캔하는 방식이다.
- 비트맵 인덱스는 값이 중복된 데이터가 많을 때 유리하며, 각 값에 대해 비트맵을 생성해 데이터를 빠르게 찾을 수 있다.
- **특징**:
    - 값의 중복도가 높을 때 성능이 뛰어나며, 여러 조건을 동시에 처리할 때 유리하다.
    - **읽기 작업**이 많은 시스템에서 유용하지만, 쓰기 작업이 많은 경우 성능 저하를 일으킬 수 있다.
- **예시**:
    
    ```sql
    SELECT * FROM employees WHERE gender = 'M';
    ```
    
    - `gender`에 비트맵 인덱스가 있다면 비트맵 인덱스 스캔이 발생한다.

## **파티션 스캔 (Partition Scan)**

- 테이블이 **파티셔닝(Partitioning)**된 경우, 특정 파티션을 스캔하는 방식이다.
- 테이블의 일부만을 스캔하여 데이터를 빠르게 찾는다.
- **특징**:
    - 파티션 테이블에서는 각 파티션에 저장된 데이터만 스캔하므로, 테이블 전체를 스캔하는 것보다 빠르다.
    - 파티션을 적절히 설계하면 성능이 크게 향상된다.
- **예시**:
    
    ```sql
    SELECT * FROM sales WHERE sales_date BETWEEN '2023-01-01' AND '2023-01-31';
    ```
    
    `sales_date`를 기준으로 파티셔닝된 테이블에서 해당 범위에 속한 파티션만을 스캔하게 된다.
    

---

# 정리

- 실행 계획에서 나오는 **스캔 종류**는 데이터베이스가 데이터를 검색하는 방식을 설명하며, 쿼리 성능 최적화에 중요한 정보를 제공한다.
- 적절한 **스캔 방식**을 사용하면 쿼리 성능을 크게 개선할 수 있지만, 비효율적인 스캔이 발생하면 성능이 저하될 수 있다.
- 각각의 스캔 방식은 쿼리의 조건, 테이블 크기, 인덱스 구조 등에 따라 달라지며, 이를 적절히 활용하여 쿼리를 최적화하는 것이 중요하다.

---

# 요약

- **풀 테이블 스캔**:
    - 모든 데이터를 스캔하며, 인덱스가 없거나 조건이 인덱스를 사용하지 못할 때 발생. 대규모 테이블에서는 성능 저하의 원인이 될 수 있다.
- **인덱스 스캔**:
    - 인덱스의 모든 값을 스캔하며, 조건이 인덱스를 사용할 수 있을 때 발생. 대규모 인덱스에서 성능 저하 가능성.
- **인덱스 탐색(Seek)**:
    - 특정 값이나 좁은 범위를 검색할 때 사용되며, 가장 빠르고 효율적인 스캔 방식 중 하나.
- **인덱스 전 범위 스캔**:
    - 인덱스의 모든 값을 정렬된 순서로 스캔하며, 인덱스가 이미 정렬된 데이터에 사용될 때 효율적이다.
- **인덱스 범위 스캔**:
    - 특정 범위의 데이터를 효율적으로 검색할 때 사용되며, 범위 조건에 적합.
- **인덱스 스킵 스캔**:
    - 다중 컬럼 인덱스에서 첫 번째 컬럼이 아닌 다른 컬럼을 기준으로 검색할 때 사용되지만, 효율성이 떨어질 수 있다.
- **비트맵 인덱스 스캔**:
    - 값의 중복도가 높을 때 성능이 뛰어나며, 읽기 작업에 적합하지만, 쓰기 성능은 저하될 수 있다.
- **파티션 스캔**:
    - 파티셔닝된 테이블에서 특정 파티션만 스캔해 성능을 높일 수 있다.

---

# 최적화 방안

- **인덱스 생성**:
    - 자주 사용하는 검색 조건에 맞는 인덱스를 생성하여 풀 테이블 스캔을 피한다.
- **인덱스 재사용**:
    - 범위 검색, 조인, 정렬 등에 맞는 인덱스를 설정하여, 인덱스 탐색 또는 인덱스 스캔으로 성능을 향상시킨다.
- **실행 계획 분석**:
    - 실행 계획을 주기적으로 분석하고, 비효율적인 스캔이 발생하지 않도록 쿼리를 최적화한다.