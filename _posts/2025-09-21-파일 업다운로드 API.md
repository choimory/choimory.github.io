---
title: "파일 업다운로드 API"
date: 2025-09-21T00:00:00
toc: true
toc_sticky: true
categories:
    - Back-end
tags:
    - MSA
    - Architecture
---

# **파일 업/다운로드 API 설계 개념**

파일 업/다운로드 기능도 별도의 API로 분리하여 개발하는식으로 접근하는게 맞을까, 아니면 기본 로직에 포함시켜 각각의 서비스에서 처리하는게 맞을까.

파일 업/다운로드 API 설계는 시스템 아키텍처에서 중요한 결정사항. 단일 책임 원칙(Single Responsibility Principle)과 관심사 분리(Separation of Concerns) 개념이 핵심. 파일 처리는 일반적인 비즈니스 로직과 다른 특성을 가짐 (대용량 데이터 처리, 스트리밍, 메타데이터 관리, 보안 검증 등이 필요.)

마이크로서비스 아키텍처에서는 각 서비스가 명확한 책임을 가져야 하며, 파일 처리는 독립적인 도메인으로 취급되는 것이 일반적. 이는 확장성(Scalability), 유지보수성(Maintainability), 장애 격리(Fault Isolation) 측면에서 장점을 제공.

## **별도 API 구성 시 장점**

### **기술적 이점**

- **전용 최적화**: 파일 처리에 특화된 서버 구성 및 라이브러리 사용 가능
- **독립적 확장**: 파일 업로드 트래픽 증가 시 해당 서비스만 스케일 아웃
- **메모리 관리**: 대용량 파일 처리 시 메인 서비스의 메모리 부담 없음
- **스트리밍 처리**: 청크 업로드, 단계적 다운로드 등 고급 기능 구현 용이

### **운영 및 보안 이점**

- **장애 격리**: 파일 서비스 장애가 메인 서비스에 영향 없음
- **보안 경계**: 파일 검증, 바이러스 스캔 등 보안 로직 분리
- **모니터링**: 파일 관련 메트릭 독립 추적 가능
- **캐싱 전략**: 파일별 CDN 연동, 캐시 정책 독립 적용

### **개발 및 유지보수**

- **팀 분리**: 파일 처리 전담 팀 운영 가능
- **기술 스택**: 파일 처리에 최적화된 언어/프레임워크 선택 자유
- **버전 관리**: 파일 API 변경이 메인 서비스에 미치는 영향 최소화

## **기존 서비스 API 포함 시 장점**

### **개발 효율성**

- **단순한 구조**: 하나의 코드베이스로 관리
- **트랜잭션 일관성**: 파일 업로드와 메타데이터 저장을 하나의 트랜잭션으로 처리
- **개발 속도**: 별도 서비스 구축 없이 빠른 기능 구현
- **디버깅 용이**: 하나의 서비스에서 전체 플로우 추적 가능

### **운영 복잡도 감소**

- **배포 단순화**: 하나의 서비스만 배포하면 됨
- **인프라 비용**: 별도 서버 없이 기존 리소스 활용
- **네트워크 레이턴시**: 서비스 간 통신 오버헤드 없음

## **선택 기준 및 고려사항**

### **파일 특성 분석**

- **파일 크기**: 소용량(1MB 미만) vs 대용량(100MB 이상)
- **업로드 빈도**: 가끔 vs 빈번한 업로드
- **파일 유형**: 이미지, 문서, 미디어 등
- **처리 복잡도**: 단순 저장 vs 변환/압축 필요

### **시스템 요구사항**

- **동시 사용자 수**: 소규모(100명 미만) vs 대규모(1000명 이상)
- **가용성 요구사항**: 일반적 vs 고가용성 필요
- **보안 수준**: 기본적 vs 엄격한 보안 정책
- **확장성**: 현재 요구사항 vs 미래 확장성

### **팀 및 리소스**

- **개발팀 규모**: 소규모 vs 여러 팀
- **운영 경험**: 모노리스 vs 마이크로서비스 경험
- **인프라 예산**: 제한적 vs 충분한 예산

## **하이브리드 접근법**

### **단계적 분리**

- **1단계**: 기존 API에 파일 기능 구현
- **2단계**: 파일 처리 로직을 별도 모듈로 분리
- **3단계**: 독립 서비스로 완전 분리

### **API Gateway 패턴**

- **통합 엔드포인트**: 클라이언트는 하나의 API Gateway 호출
- **내부 라우팅**: Gateway에서 파일 요청을 전용 서비스로 라우팅
- **투명한 전환**: 클라이언트 변경 없이 내부 구조 변경 가능

## **실제 구현 고려사항**

### **별도 API 구성 시 주의점**

- **서비스 디스커버리**: 파일 서비스 위치 관리
- **인증/인가**: 서비스 간 보안 토큰 전달
- **에러 핸들링**: 분산 환경에서의 에러 처리
- **데이터 일관성**: 파일과 메타데이터 동기화

### **통합 구현 시 주의점**

- **메모리 사용량**: 대용량 파일 처리 시 OOM 위험
- **응답 시간**: 파일 처리로 인한 전체 API 응답 지연
- **코드 복잡도**: 파일 처리 로직과 비즈니스 로직 혼재

## **요약**

파일 업/다운로드 API 설계는 시스템 규모와 요구사항에 따라 결정해야 함. 소규모이고 단순한 파일 처리가 필요한 경우 기존 서비스에 포함하여 빠른 개발이 가능. 하지만 대용량 파일, 높은 트래픽, 복잡한 파일 처리가 예상되면 별도 API로 구성하여 확장성과 안정성을 확보하는 것이 유리.

초기에는 통합 구현으로 시작하되, 파일 처리 로직을 모듈화하여 나중에 독립 서비스로 분리할 수 있도록 설계하는 하이브리드 접근이 현실적. 핵심은 단일 책임 원칙을 지키면서도 과도한 복잡성을 피하는 균형점 찾기.