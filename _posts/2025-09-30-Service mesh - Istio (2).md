---
title: "Service mesh - Istio (2)"
date: 2025-09-30T00:00:02
toc: true
toc_sticky: true
categories:
    - DevOps
tags:
    - Kubernetes
    - Mesh
    - Istio
---

# Istio의 개념과 아키텍처

## Istio란 무엇인가

Istio는 Google, IBM, Lyft가 공동 개발한 오픈소스 서비스 메쉬 플랫폼이다. 마이크로서비스 간 통신을 연결, 보호, 제어, 관찰하는 기능을 제공하며, 현재 가장 널리 사용되는 서비스 메쉬 구현체다.

- 애플리케이션 코드 수정 없이 서비스 메쉬 기능을 투명하게 추가한다
- Kubernetes 환경에서 가장 잘 작동하지만 VM 환경도 지원한다
- Envoy 프록시를 데이터 플레인으로 사용하여 검증된 성능과 안정성을 보장한다
- CNCF(Cloud Native Computing Foundation) 프로젝트로 활발히 발전하고 있다

## 핵심 아키텍처

### Istiod (Control Plane)

Istio 1.5 버전부터 여러 컴포넌트가 단일 바이너리로 통합되었다.

- **Pilot**: 서비스 디스커버리와 트래픽 관리를 담당한다
- **Citadel**: 인증서 발급과 순환을 자동화한다
- **Galley**: 설정 검증과 배포를 처리한다
- Kubernetes API 서버와 통신하여 서비스와 엔드포인트 정보를 수집한다
- 모든 Envoy 프록시에 설정을 배포하고 동기화한다
- 단일 컨트롤 플레인으로 통합되어 배포와 운영이 간소화되었다

### Envoy Proxy (Data Plane)

각 서비스의 사이드카로 배치되는 고성능 프록시다.

- C++로 작성되어 뛰어난 성능과 낮은 메모리 사용량을 자랑한다
- 동적 설정을 지원하여 재시작 없이 설정을 변경할 수 있다
- HTTP/1.1, HTTP/2, gRPC, TCP 등 다양한 프로토콜을 지원한다
- 풍부한 메트릭과 로그를 자동으로 생성한다
- xDS API를 통해 Istiod로부터 동적으로 설정을 받는다

### Ingress/Egress Gateway

클러스터 경계에서 트래픽을 제어하는 특수한 Envoy 프록시다.

- **Ingress Gateway**: 외부에서 들어오는 트래픽의 진입점이다
- **Egress Gateway**: 클러스터 내부에서 외부로 나가는 트래픽을 제어한다
- 로드 밸런싱, TLS 종료, 라우팅 규칙 적용을 담당한다
- 단일 진입/이탈점을 제공하여 보안 정책을 집중 관리한다

## 트래픽 관리 기능

### Virtual Service

서비스로 향하는 트래픽의 라우팅 규칙을 정의한다.

- HTTP 헤더, URI, 쿠키 등을 기반으로 요청을 라우팅한다
- 가중치 기반 트래픽 분배로 카나리 배포를 구현한다
- 재시도, 타임아웃, 장애 주입 등의 정책을 설정한다
- 여러 버전의 서비스 간 트래픽 비율을 세밀하게 조정한다
- 예를 들어 v1에 90%, v2에 10%의 트래픽을 보낼 수 있다

### Destination Rule

서비스의 하위 집합(subset)과 정책을 정의한다.

- 서비스의 여러 버전을 subset으로 그룹화한다
- 로드 밸런싱 알고리즘을 지정한다(라운드 로빈, 랜덤, 최소 요청)
- 연결 풀 크기와 아웃라이어 감지 설정을 구성한다
- TLS 설정과 서킷 브레이커 정책을 적용한다

### Gateway

클러스터 경계에서의 트래픽을 관리한다.

- 어떤 포트와 프로토콜을 노출할지 정의한다
- TLS 인증서와 SNI 설정을 구성한다
- Virtual Service와 결합하여 외부 트래픽 라우팅을 완성한다
- Kubernetes Ingress보다 더 풍부한 기능을 제공한다

### Service Entry

메쉬 외부 서비스를 메쉬에 등록한다.

- 외부 API나 레거시 시스템을 서비스 메쉬에 통합한다
- 외부 서비스에 대한 트래픽도 동일한 정책으로 관리한다
- DNS 해상도 설정과 엔드포인트를 명시적으로 지정한다

## 보안 기능

### 자동 mTLS

서비스 간 통신을 자동으로 암호화하고 인증한다.

- 각 서비스에 고유한 SPIFFE ID를 부여한다
- X.509 인증서를 자동으로 발급하고 순환한다(기본 90일)
- 애플리케이션 코드 수정 없이 전송 계층 보안을 제공한다
- Permissive 모드로 점진적 마이그레이션을 지원한다(평문과 mTLS 동시 허용)
- Strict 모드에서는 mTLS만 허용하여 높은 보안을 보장한다

### Authorization Policy

세밀한 접근 제어를 구현한다.

- 서비스, 네임스페이스, 메서드 수준의 접근 제어를 정의한다
- ALLOW, DENY, CUSTOM 액션을 지원한다
- 요청의 소스(서비스 계정, IP), 작업(HTTP 메서드, 경로), 조건을 기준으로 평가한다
- JWT 토큰 검증과 클레임 기반 인가를 수행한다

### Peer Authentication

mTLS 모드를 설정한다.

- STRICT: mTLS만 허용
- PERMISSIVE: mTLS와 평문 모두 허용
- DISABLE: mTLS 비활성화
- 워크로드 수준, 네임스페이스 수준, 메쉬 수준에서 설정 가능하다

### Request Authentication

JWT 기반 인증을 구성한다.

- OIDC 제공자(Auth0, Keycloak 등)와 통합한다
- JWT 발급자와 공개 키를 검증한다
- 유효하지 않은 토큰을 가진 요청을 거부한다

## 관찰성 기능

### 메트릭 수집

모든 트래픽에 대한 상세한 메트릭을 자동 생성한다.

- 요청 수, 지연 시간, 에러율을 측정한다
- RED 메트릭(Rate, Errors, Duration)을 기본 제공한다
- Prometheus 형식으로 메트릭을 노출한다
- Golden Signals(지연, 트래픽, 에러, 포화도)를 추적한다

### 분산 추적

요청이 여러 서비스를 거치는 경로를 추적한다.

- Jaeger, Zipkin, Lightstep과 통합된다
- B3 전파 헤더를 자동으로 추가한다
- 애플리케이션은 헤더만 전파하면 나머지는 Istio가 처리한다
- 병목 지점과 장애 발생 위치를 시각적으로 파악한다

### 접근 로그

모든 요청/응답을 상세히 기록한다.

- 요청 메서드, 경로, 상태 코드, 지연 시간을 로깅한다
- 표준 출력이나 파일로 로그를 출력한다
- 커스텀 로그 포맷을 정의할 수 있다

### Kiali 대시보드

서비스 메쉬를 시각화하는 웹 UI다.

- 서비스 간 의존성을 그래프로 표현한다
- 실시간 트래픽 흐름과 에러를 시각화한다
- Istio 설정을 검증하고 문제를 진단한다
- Virtual Service, Destination Rule 등을 GUI로 관리한다

## 고급 트래픽 관리 패턴

### 카나리 배포

새 버전을 점진적으로 롤아웃한다.

- Virtual Service에서 가중치를 조절하여 트래픽 비율을 변경한다
- 10% → 50% → 100%로 단계적으로 증가시킨다
- 문제 발생 시 즉시 이전 버전으로 롤백한다
- Flagger 같은 도구와 연동하여 자동화한다

### A/B 테스팅

특정 사용자 그룹에게 다른 버전을 제공한다.

- HTTP 헤더(사용자 ID, 쿠키)를 기반으로 라우팅한다
- 특정 조건을 만족하는 요청만 새 버전으로 보낸다
- 두 버전의 성능을 비교 분석한다

### 미러링

프로덕션 트래픽을 복제하여 테스트한다.

- 실제 요청을 라이브 버전과 테스트 버전에 동시에 전송한다
- 테스트 버전의 응답은 무시하고 라이브 버전의 응답만 사용자에게 반환한다
- 실제 트래픽 패턴으로 새 버전을 검증한다

### 서킷 브레이킹

장애가 있는 서비스로의 요청을 차단한다.

- 연속된 오류가 임계값을 초과하면 회로를 차단한다
- 일정 시간 후 일부 요청을 허용하여 회복 여부를 확인한다
- 연쇄 장애 전파를 방지하고 시스템 안정성을 높인다

### 재시도와 타임아웃

일시적 장애를 자동으로 처리한다.

- 실패한 요청을 자동으로 재시도한다
- 지수 백오프와 지터를 적용하여 부하를 분산한다
- 요청당 최대 대기 시간을 설정하여 무한 대기를 방지한다

### 장애 주입

시스템의 복원력을 테스트한다.

- 특정 비율의 요청에 지연을 주입한다
- 일부 요청을 강제로 실패시킨다
- 카오스 엔지니어링을 실천하여 시스템 취약점을 발견한다

## 설치와 구성

### 설치 프로파일

사용 사례에 맞는 프리셋 구성이다.

- **default**: 프로덕션 배포용 기본 구성
- **demo**: 학습과 테스트용으로 모든 기능 포함
- **minimal**: 최소한의 컴포넌트만 설치
- **preview**: 실험적 기능 포함
- **empty**: 커스텀 구성을 위한 빈 프로파일

### Sidecar 주입

서비스에 Envoy 프록시를 추가하는 방법이다.

- **자동 주입**: 네임스페이스에 `istio-injection=enabled` 레이블 추가
- **수동 주입**: `istioctl kube-inject` 명령으로 명시적 주입
- Pod 생성 시 Mutating Admission Webhook이 사이드카를 자동 삽입한다
- 기존 애플리케이션 YAML 수정이 불필요하다

### IstioOperator

선언적 방식으로 Istio를 설치하고 관리한다.

- YAML로 원하는 구성을 정의한다
- 컴포넌트별 활성화/비활성화와 리소스 할당을 설정한다
- `istioctl` 또는 Operator를 통해 적용한다

## 멀티 클러스터 구성

여러 Kubernetes 클러스터에 걸친 서비스 메쉬를 구축한다.

### Primary-Remote

하나의 컨트롤 플레인이 여러 클러스터를 관리한다.

- Primary 클러스터에만 Istiod가 설치된다
- Remote 클러스터는 Primary의 컨트롤 플레인을 사용한다
- 관리가 간단하지만 Primary가 단일 장애점이 된다

### Multi-Primary

각 클러스터에 독립적인 컨트롤 플레인이 있다.

- 높은 가용성과 지역 복원력을 제공한다
- 클러스터 간 서비스 디스커버리가 필요하다
- 더 복잡한 네트워크 구성이 필요하다

### 네트워크 구성

- **단일 네트워크**: 모든 Pod가 직접 통신 가능
- **다중 네트워크**: East-West Gateway를 통한 통신

## 성능과 최적화

### 리소스 사용

Istio는 상당한 오버헤드를 발생시킨다.

- Envoy 사이드카당 약 50-100MB 메모리 사용
- 요청당 1-3ms의 추가 지연 발생
- CPU 사용량은 트래픽 양에 비례하여 증가한다
- 대규모 클러스터에서는 Istiod도 상당한 리소스를 소비한다

### 최적화 전략

- **선택적 배포**: 필요한 서비스에만 사이드카를 주입한다
- **리소스 튜닝**: 사이드카의 CPU/메모리 요청과 제한을 조정한다
- **프로토콜 선택**: HTTP/2와 gRPC 사용으로 오버헤드를 줄인다
- **메트릭 필터링**: 불필요한 메트릭 수집을 비활성화한다
- **Ambient 메쉬**: 사이드카 없는 경량 모드를 사용한다

## Ambient 메쉬 (신규 아키텍처)

Istio 1.18에서 도입된 사이드카 없는 구조다.

### Ztunnel (Zero-Trust Tunnel)

노드 레벨에서 작동하는 경량 프록시다.

- 각 노드에 하나의 ztunnel만 배치된다
- mTLS, 텔레메트리, L4 인가를 처리한다
- 사이드카 대비 리소스 사용량이 크게 감소한다

### Waypoint Proxy

L7 기능이 필요할 때만 선택적으로 배치한다.

- Virtual Service, 장애 주입 등 고급 기능을 제공한다
- 서비스나 네임스페이스 수준에서 배포한다
- 세밀한 제어가 필요한 곳에만 추가 오버헤드를 부담한다

### 장점

- 애플리케이션 Pod 재시작 없이 Istio를 도입/제거할 수 있다
- 전체 리소스 사용량이 50% 이상 감소한다
- 점진적 도입이 더욱 쉬워진다

## 문제 해결과 디버깅

### istioctl 도구

명령줄에서 Istio를 관리하고 진단한다.

- `istioctl analyze`: 구성 오류를 검출한다
- `istioctl proxy-status`: 모든 프록시의 상태를 확인한다
- `istioctl proxy-config`: Envoy 설정을 조회한다
- `istioctl dashboard`: Kiali, Grafana 등을 실행한다

### 일반적인 문제

- **사이드카 미주입**: 네임스페이스 레이블 확인
- **mTLS 실패**: PeerAuthentication 정책 충돌 검사
- **라우팅 불일치**: Virtual Service와 Destination Rule의 subset 이름 일치 확인
- **Gateway 연결 실패**: Gateway와 Virtual Service의 hosts 매칭 확인

### 로깅 레벨 조정

더 상세한 디버깅 정보를 수집한다.

- Envoy 로그 레벨을 동적으로 변경한다
- 특정 컴포넌트만 debug 레벨로 설정한다
- 문제 해결 후 다시 info 레벨로 복원한다

## 전체 요약

Istio는 Envoy 프록시 기반의 강력한 서비스 메쉬 플랫폼으로, Istiod 컨트롤 플레인이 모든 사이드카를 중앙 관리한다. Virtual Service, Destination Rule, Gateway 등의 리소스로 트래픽을 세밀하게 제어하며, 자동 mTLS과 Authorization Policy로 보안을 강화한다. 메트릭, 추적, 로깅을 자동 생성하여 전체 시스템을 관찰할 수 있고, Kiali로 시각화한다. 카나리 배포, A/B 테스트, 서킷 브레이킹 같은 고급 패턴을 코드 변경 없이 구현한다. 리소스 오버헤드가 있지만 새로운 Ambient 메쉬로 이를 크게 줄일 수 있다. istioctl 도구와 다양한 진단 기능으로 문제를 해결하며, 멀티 클러스터 구성으로 확장 가능하다.
