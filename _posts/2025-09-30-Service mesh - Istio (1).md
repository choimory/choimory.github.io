---
title: "Service mesh - Istio (1)"
date: 2025-09-30T00:00:00
toc: true
toc_sticky: true
categories:
    - DevOps
tags:
    - Kubernetes
    - Mesh
    - Istio
---

# 선요약

- Ingress
    - 쿠버네티스 전체에 대한 리버스 프록시
    - 외부에서 내부 통신시에 대한 리버스 프록시
    - Kubernetes 차원에서 Ingress를 지원하며 Nginx ingress controller가 대표적인 Ingress 구현체
- Service mesh
    - 각각의 서비스 팟에 대한 리버스 프록시
    - 내부에서 내부 통신시에 대한 리버스 프록시
    - Kubernetes 차원에서 mesh를 지원하며 Istio가 대표적인 구현체
    - Istio의 각각의 프록시를 사이드카로 호칭하며 Envoy가 대표적인 사이드카 구현체

---

# 서비스 메쉬의 개념과 구조

## 서비스 메쉬의 정의

서비스 메쉬는 마이크로서비스 아키텍처에서 서비스 간 통신을 관리하는 전용 인프라 계층이다. 애플리케이션 코드와 분리되어 네트워크 통신을 투명하게 처리하며, 각 서비스 인스턴스 옆에 프록시(사이드카)를 배치하여 모든 네트워크 트래픽을 중개한다.

- 애플리케이션 로직과 네트워크 로직의 분리를 통해 개발자가 비즈니스 로직에만 집중할 수 있게 한다
- 서비스 간 통신의 복잡성을 인프라 레벨에서 해결한다
- 분산 시스템에서 발생하는 통신 문제를 일관되게 처리한다

## 핵심 구성 요소

### 데이터 플레인 (Data Plane)

실제 네트워크 트래픽을 처리하는 계층이다.

- 각 서비스 인스턴스마다 사이드카 프록시가 배치된다
- 모든 인바운드/아웃바운드 트래픽이 이 프록시를 거친다
- Envoy, Linkerd-proxy 등이 대표적인 프록시다
- 요청 라우팅, 로드 밸런싱, 암호화, 인증을 실시간으로 수행한다

### 컨트롤 플레인 (Control Plane)

데이터 플레인을 관리하고 설정하는 중앙 제어 계층이다.

- 모든 프록시의 설정과 정책을 중앙에서 관리한다
- 서비스 디스커버리 정보를 프록시에 배포한다
- 텔레메트리 데이터를 수집하고 집계한다
- 보안 정책과 트래픽 규칙을 배포한다

## 주요 기능

### 트래픽 관리

- **로드 밸런싱**: 라운드 로빈, 최소 연결, 해시 기반 등 다양한 알고리즘을 지원한다
- **서비스 디스커버리**: 동적으로 변하는 서비스 인스턴스를 자동으로 감지한다
- **라우팅 규칙**: URL 경로, 헤더, 가중치 기반으로 트래픽을 분배한다
- **트래픽 분할**: 카나리 배포, A/B 테스트를 위한 점진적 롤아웃을 지원한다
- **서킷 브레이커**: 장애가 있는 서비스로의 요청을 차단하여 연쇄 장애를 방지한다

### 보안

- **mTLS (Mutual TLS)**: 서비스 간 통신을 자동으로 암호화하고 양방향 인증을 수행한다
- **인증/인가**: 서비스 수준의 접근 제어를 구현한다
- **인증서 관리**: 인증서의 자동 발급, 갱신, 순환을 처리한다
- **정책 기반 제어**: 세밀한 접근 정책을 정의하고 강제한다

### 관찰성 (Observability)

- **분산 추적**: 요청이 여러 서비스를 거치는 전체 경로를 추적한다
- **메트릭 수집**: 지연 시간, 에러율, 트래픽 양 등을 자동으로 수집한다
- **로깅**: 모든 요청/응답을 상세히 기록한다
- **시각화**: Grafana, Kiali 등과 연동하여 서비스 간 관계를 시각적으로 보여준다

## 대표적인 서비스 메쉬 구현체

### Istio

가장 널리 사용되는 오픈소스 서비스 메쉬다.

- Envoy를 데이터 플레인 프록시로 사용한다
- 풍부한 기능과 강력한 트래픽 관리 능력을 제공한다
- Kubernetes와의 깊은 통합을 지원한다
- 상대적으로 복잡한 아키텍처와 높은 리소스 사용량이 단점이다

### Linkerd

경량화와 단순성에 초점을 맞춘 서비스 메쉬다.

- Rust로 작성된 자체 프록시를 사용한다
- 낮은 리소스 오버헤드와 빠른 성능을 자랑한다
- 설치와 운영이 상대적으로 간단하다
- CNCF에서 졸업한 프로젝트다

### Consul Connect

HashiCorp의 Consul에 포함된 서비스 메쉬 기능이다.

- 멀티 클라우드와 멀티 플랫폼을 지원한다
- Kubernetes뿐만 아니라 VM 환경도 지원한다
- Consul의 서비스 디스커버리와 자연스럽게 통합된다

## 서비스 메쉬가 필요한 이유

### 마이크로서비스의 복잡성

- 수십, 수백 개의 서비스가 서로 통신하는 환경에서 통신 로직을 각 서비스에 구현하면 중복과 불일치가 발생한다
- 서비스마다 다른 언어와 프레임워크를 사용할 때 일관된 통신 패턴을 구현하기 어렵다
- 네트워크 관련 문제(재시도, 타임아웃, 서킷 브레이킹)를 각 팀이 개별적으로 해결하면 비효율적이다

### 운영상의 이점

- 애플리케이션 코드 수정 없이 트래픽 정책을 변경할 수 있다
- 중앙 집중식 관리로 보안 정책을 일관되게 적용한다
- 전체 시스템의 동작을 실시간으로 관찰하고 문제를 빠르게 진단한다
- 새로운 서비스를 배포할 때 네트워크 관련 인프라를 자동으로 제공받는다

## 도입 시 고려사항

### 복잡성과 학습 곡선

- 새로운 컴포넌트 도입으로 시스템 전체가 복잡해진다
- 팀원들이 서비스 메쉬의 개념과 운영 방법을 학습해야 한다
- 문제 발생 시 디버깅 범위가 넓어진다

### 성능 오버헤드

- 모든 요청이 프록시를 거치면서 약간의 지연이 추가된다
- 사이드카 프록시가 추가 CPU와 메모리를 소비한다
- 소규모 서비스에서는 오버헤드가 이점을 상쇄할 수 있다

### 적용 시점

- 서비스가 10개 미만일 때는 필요하지 않을 수 있다
- 서비스 간 통신 패턴이 단순하다면 더 간단한 솔루션으로 충분하다
- 마이크로서비스 아키텍처가 성숙하고 복잡도가 증가할 때 도입을 고려한다

## 구현 패턴

### 사이드카 패턴

가장 일반적인 구현 방식이다.

- 각 애플리케이션 컨테이너 옆에 프록시 컨테이너를 배치한다
- Kubernetes에서는 같은 Pod 내에 두 컨테이너가 공존한다
- 애플리케이션은 localhost로 통신하면 프록시가 중개한다
- 애플리케이션 코드의 변경이 필요 없다

### Ambient 메쉬

최근 Istio에서 제안한 새로운 방식이다.

- 사이드카 없이 노드 레벨에서 트래픽을 처리한다
- 리소스 오버헤드를 크게 줄인다
- 기본 기능은 ambient 모드로, 고급 기능이 필요할 때만 사이드카를 추가한다

## 전체 요약

서비스 메쉬는 마이크로서비스 간 통신을 관리하는 전용 인프라 계층으로, 애플리케이션 코드와 분리하여 네트워크 로직을 처리한다. 데이터 플레인의 사이드카 프록시가 실제 트래픽을 중개하고, 컨트롤 플레인이 이를 중앙에서 관리한다. 트래픽 관리, 보안(mTLS), 관찰성 등의 기능을 제공하여 복잡한 마이크로서비스 환경에서 일관된 통신 패턴을 구현한다. Istio, Linkerd, Consul Connect 같은 구현체가 있으며, 각각 특성이 다르다. 도입 시 복잡성과 오버헤드를 고려해야 하며, 서비스 규모와 복잡도가 충분히 클 때 그 가치가 드러난다.