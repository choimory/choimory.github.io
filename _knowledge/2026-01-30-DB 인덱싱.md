---
title: "DB 인덱싱"
date: 2026-01-30T00:00:00
toc: true
toc_sticky: true
categories:
    - DB
tags:
    - Index
---

# DB 인덱싱

- DB 인덱싱(Database Indexing)은 데이터베이스에서 **데이터 검색 성능을 최적화**하기 위한 기술이다.
- 인덱스는 데이터베이스 테이블의 한두 개 열(Column)을 기반으로 별도의 데이터 구조를 만들어, 특정 데이터를 **빠르게 조회**할 수 있게 해준다.
- 인덱스는 책의 목차와 유사한 역할을 하며, 검색을 빠르게 할 수 있는 **자료 구조**를 제공한다.

---

# 인덱싱의 기본 원리

- 데이터베이스에서 인덱스를 사용하는 주된 이유는 **검색 속도**를 높이는 것이다.
- 인덱스가 없는 테이블에서 데이터를 검색할 때는 데이터베이스가 테이블의 **모든 행을 순차적으로 탐색**해야 하는데, 이를 풀 테이블 스캔(full table scan)이라고 한다.
- 반면 인덱스를 사용하면, 인덱스에 저장된 정보만을 사용해 필요한 데이터를 훨씬 빠르게 찾을 수 있다.

## **인덱스 생성**:

- 인덱스는 테이블의 특정 열을 기반으로 **정렬된 데이터 구조**를 생성하며, 각 값과 해당 값이 저장된 데이터 위치(포인터)를 함께 저장한다.
- 예시:
    - 위 예시에서는 `customer_name` 컬럼에 인덱스를 생성하여, 고객 이름으로 데이터를 빠르게 조회할 수 있게 한다.
    
    ```sql
    CREATE INDEX idx_customer_name ON customers (customer_name);
    ```
    

## **검색 최적화**:

- 인덱스가 있으면 데이터베이스는 해당 열에 대한 인덱스를 먼저 검색하고, 인덱스에서 찾은 포인터를 사용해 실제 테이블에서 데이터를 가져온다.
- 이를 통해 **전체 테이블을 스캔하지 않고도** 필요한 데이터를 빠르게 찾을 수 있다.

## **인덱스와 데이터 정렬**:

- 인덱스는 데이터가 **정렬된 상태**로 저장되므로, 특히 **범위 검색**이나 **정렬**이 필요한 경우에 유리하다.
- 예를 들어 `ORDER BY`나 `WHERE` 조건에서 인덱스가 있는 컬럼을 사용하면 성능이 크게 향상된다.

---

# 인덱스의 종류

- 데이터베이스에서는 다양한 종류의 인덱스가 제공되며, 각 인덱스는 특정한 상황에서 최적화된 성능을 제공한다.

## **B-Tree 인덱스**

- 가장 일반적으로 사용되는 인덱스 구조로, **균형 트리(Balanced Tree)** 형태를 사용한다. B-Tree 인덱스는 **데이터를 빠르게 찾고** **범위 검색**에 매우 유리하다.
- **특징**:
    - 모든 리프 노드는 같은 깊이에 있어 검색 성능이 일정하다.
    - 삽입, 삭제 시에도 트리가 자동으로 균형을 유지한다.
    - 데이터가 정렬되어 있으므로 범위 검색이 효율적이다.
    - 대부분의 데이터베이스에서 기본적으로 사용하는 인덱스이며, 특히 **범위 검색**, **정렬**, **순차적 접근**에 유리하다.

## **Hash 인덱스**

- 해시 함수를 사용하여 키 값을 **해시 값으로 변환**하고, 이를 기반으로 데이터를 검색하는 방식이다.
- **특징**:
    - 정확히 일치하는 값을 찾는 데 최적화되어 있다.
    - 범위 검색에는 적합하지 않다.
    - 데이터가 고르게 분포된 경우에 빠른 검색 성능을 제공한다.
    - **정확한 값 검색**(예: ID, 이메일 주소)과 같이 특정한 값을 검색할 때 효과적이다. 범위 검색을 지원하지 않기 때문에, 특정 쿼리에만 적합하다.

## **비트맵 인덱스(Bitmap Index)**

- **비트맵**을 사용하여 데이터를 인덱싱하는 방식이다. 각 열의 값에 대해 비트를 사용하여 데이터를 나타낸다.
- **특징**:
    - 값의 종류가 적고 데이터 중복이 많은 경우에 유리하다.
    - 비트 연산을 통해 대량의 데이터를 효율적으로 처리할 수 있다.
    - 쓰기 작업이 많은 경우 성능 저하가 발생할 수 있다.
    - **성별, 상태값, Boolean 값**과 같은 **카디널리티(값의 종류)가 낮은** 데이터를 인덱싱할 때 사용된다.

## **클러스터드 인덱스(Clustered Index)**

- 테이블의 데이터 자체를 **정렬된 순서로 저장**하는 인덱스이다. 하나의 테이블에는 하나의 클러스터드 인덱스만 생성할 수 있다.
- **특징**:
    - 인덱스와 테이블 데이터가 함께 저장되어 있어, 데이터 조회 속도가 매우 빠르다.
    - 데이터가 물리적으로 정렬되어 있으므로, 범위 검색과 정렬에 매우 유리하다.
    - **기본 키**나 **주요 컬럼**에 클러스터드 인덱스를 사용하여 빠른 조회 성능을 보장한다.

## **비클러스터드 인덱스(Non-clustered Index)**

- 클러스터드 인덱스와 달리, 데이터는 정렬되지 않으며 **인덱스와 실제 데이터가 별도로 저장**된다.
- **특징**:
    - 한 테이블에 여러 개의 비클러스터드 인덱스를 생성할 수 있다.
    - 인덱스는 실제 데이터의 위치를 가리키는 포인터를 저장한다.
    - 보조 인덱스로 사용되며, 다양한 열에 대해 여러 개의 인덱스를 설정하여 조회 성능을 높일 수 있다.

## **복합 인덱스(Composite Index)**

- 여러 개의 열(Column)을 결합하여 하나의 인덱스를 생성하는 방식이다.
- **특징**:
    - 여러 컬럼을 기준으로 데이터를 검색할 때 성능이 향상된다.
    - 복합 인덱스의 첫 번째 열을 기준으로 검색할 때만 인덱스가 효과적이다.
    - 두 개 이상의 열을 자주 함께 검색하는 경우 사용된다. 예를 들어, `first_name`과 `last_name` 컬럼을 함께 검색하는 경우.

---

# 인덱스의 장점

- **검색 성능 향상**:
    - 인덱스를 사용하면 데이터베이스에서 데이터를 검색할 때 **훨씬 더 빠르게** 결과를 찾을 수 있다.
    - 특히 **대량의 데이터**에서 큰 성능 차이가 발생한다.
- **범위 검색에 유리**:
    - B-Tree와 같은 인덱스 구조는 데이터를 정렬된 상태로 저장하므로, **범위 검색**(예: 날짜 범위, 숫자 범위)에 매우 효과적이다.
- **정렬된 결과 제공**:
    - 인덱스를 사용하면 데이터가 이미 정렬된 상태로 저장되므로, 쿼리에서 **ORDER BY** 절을 사용할 때 추가적인 정렬 작업을 줄일 수 있다.
- **중복 제거(유니크 키)**:
    - 유니크 인덱스를 생성하면 **중복된 값**을 자동으로 방지할 수 있어, 데이터 무결성을 유지하는 데 도움이 된다.

---

# 인덱스의 단점

- **삽입/삭제/수정 성능 저하**:
    - 데이터가 삽입, 삭제, 수정될 때마다 인덱스도 함께 갱신되어야 한다.
    - 따라서 **쓰기 작업이 많은 환경**에서는 인덱스가 성능에 부정적인 영향을 줄 수 있다.
- **저장 공간 증가**:
    - 인덱스는 별도의 데이터 구조를 저장하기 때문에, 추가적인 **저장 공간**이 필요하다.
    - 인덱스를 많이 생성하면 디스크 공간을 많이 차지할 수 있다.
- **인덱스 선택 실패**:
    - 잘못된 인덱스 선택이나 과도한 인덱스 사용은 오히려 성능을 저하시킬 수 있다.
    - 또한, 쿼리에서 인덱스를 사용하지 않으면 인덱스가 존재하더라도 풀 테이블 스캔이 발생할 수 있다.

---

# 인덱스를 언제 사용하는가?

## **자주 조회하는 컬럼**:

- 검색 조건으로 자주 사용되는 컬럼에 인덱스를 생성하면 조회 성능을 크게 향상시킬 수 있다.
- 특히, **WHERE** 조건에서 자주 사용되는 컬럼에 인덱스를 적용하는 것이 좋다.

## **범위 검색이 필요한 경우**:

- 날짜나 숫자 범위를 검색할 때는 인덱스가 큰 성능 향상을 제공한다.
- **예시**
    
    ```sql
    SELECT * 
    FROM orders 
    WHERE order_date BETWEEN '2023-01-01' AND '2023-01-31';
    ```
    
    - 이 쿼리에서 `order_date` 컬럼에 인덱스가 있으면 특정 기간 내의 주문을 매우 빠르게 검색할 수 있다.

## **조인(Join) 작업이 많은 경우**:

- 여러 테이블 간의 조인 작업이 빈번한 경우, 조인에 사용되는 **키**에 인덱스를 생성하면 성능이 향상된다.
- 특히, 외래 키로 연결된 컬럼에 인덱스를 걸면 조인 성능이 크게 좋아진다.

## **정렬된 데이터를 자주 조회하는 경우**:

- 쿼리에서 `ORDER BY` 절을 자주 사용하는 경우, 해당 컬럼에 인덱스를 설정하면 정렬 작업이 빨라진다.
- 이미 인덱스가 정렬된 상태로 데이터를 유지하기 때문이다.

## **고유성 보장**:

- 특정 컬럼에 **중복 데이터가 저장되지 않도록** 해야 할 때 유니크 인덱스를 사용할 수 있다.
- 예를 들어, 사용자의 이메일 주소나 주민등록번호 같은 유일한 값을 저장하는 컬럼에 유니크 인덱스를 설정하면 데이터의 **무결성**을 보장할 수 있다.

## **조회와 쓰기 작업의 균형을 고려할 때**:

- 인덱스는 읽기 성능을 최적화하지만, 쓰기 작업(삽입, 수정, 삭제)에는 성능 저하를 일으킬 수 있다.
- 따라서 조회 쿼리가 많은 시스템에서 인덱스 사용이 특히 유리하다.

---

# 인덱스를 피해야 하는 경우

## **너무 많은 인덱스**:

- 하나의 테이블에 너무 많은 인덱스를 생성하면 데이터 변경 작업(삽입, 삭제, 수정) 시 성능 저하가 발생할 수 있다.
- 이는 데이터 변경 시마다 모든 인덱스를 갱신해야 하기 때문이다.

## **자주 변경되는 데이터**:

- 데이터가 자주 변경되는 컬럼에 인덱스를 설정하는 것은 권장되지 않는다.
- 데이터가 변경될 때마다 인덱스가 재정렬되거나 갱신되어야 하므로, 이로 인해 쓰기 성능이 크게 저하될 수 있다.

## **데이터가 작은 테이블**:

- 테이블 크기가 작을 때는 인덱스를 사용해도 성능 향상이 크지 않다.
- 테이블 전체를 스캔하는 것이 더 효율적일 수 있기 때문에, 소규모 테이블에는 인덱스가 불필요한 경우가 많다.

## **중복 값이 많은 컬럼**:

- 인덱스는 **중복 값이 적을수록** 효과적이다. 중복 값이 많은 컬럼(예: `성별`과 같은 이진값)에 인덱스를 설정하면 성능 이점이 거의 없다.
- 이러한 경우 비트맵 인덱스와 같은 대체 인덱스를 고려할 수 있다.

---

# 인덱스 성능 최적화 팁

## **적절한 컬럼에 인덱스 생성**:

- 자주 쿼리되는 컬럼, 조인에 사용되는 컬럼, 정렬이나 그룹화에 사용되는 컬럼에 인덱스를 생성하면 성능이 향상된다.
- 하지만 모든 컬럼에 인덱스를 생성하면 쓰기 성능에 부정적인 영향을 미칠 수 있으므로 적절한 균형을 유지해야 한다.

## **복합 인덱스 사용**:

- 여러 개의 컬럼을 기준으로 자주 조회되는 경우에는 복합 인덱스를 사용하여 성능을 최적화할 수 있다.
- 단, 복합 인덱스는 첫 번째 컬럼을 기준으로 검색할 때만 유효하다는 점을 기억해야 한다.

## **인덱스 재빌드(Rebuild)**:

- 시간이 지나면서 인덱스가 조각화(Fragmentation)될 수 있다.
- 이 경우 인덱스를 재구성(Rebuild)하거나 재조정(Reorganize)하여 인덱스 성능을 유지할 수 있다.

## **쿼리 계획 확인**:

- 쿼리를 실행하기 전에 쿼리 계획(Query Plan)을 확인하여 인덱스가 실제로 사용되고 있는지 확인하는 것이 중요하다.
- 쿼리 최적화기(Query Optimizer)가 적절한 인덱스를 선택하지 못할 경우 인덱스가 존재하더라도 성능 향상을 기대하기 어렵다.

---

# 정리

- **DB 인덱싱**은 데이터베이스에서 성능 최적화의 중요한 요소로, 적절하게 사용하면 데이터 조회 성능을 크게 향상시킬 수 있다.
- 인덱스는 특히 대규모 데이터를 다루는 시스템에서 효율적인 데이터 접근을 가능하게 하며, 잘 설계된 인덱스는 읽기 성능을 최적화할 수 있다.
- 그러나 인덱스를 과도하게 사용하거나 적절하지 않은 컬럼에 인덱스를 생성하면, 오히려 쓰기 성능 저하나 저장 공간 낭비로 이어질 수 있다.
- 따라서 **적절한 인덱스 설계**와 **쿼리 최적화**가 데이터베이스 성능을 최적화하는 데 핵심적인 역할을 한다.